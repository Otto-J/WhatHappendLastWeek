{
  "startOfWeek": "2025-07-21",
  "weekNumber": 30,
  "availableItems": 11,
  "results": [
    {
      "feedTitle": "Whiskey Web and Whatnot: Web Development, Neat",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "From the Rickhouse: Tech Talk, Social Media Use, and Netflix with The Primeagen ",
          "media": "https://m.pfxes.com/vj4uqd6U/rss.art19.com/episodes/4ddb8af6-95fd-4a93-9e9e-4130d67d0bee.mp3?rss_browser=BAhJIg9yc3MtcGFyc2VyBjoGRVQ%3D--42d668516e215326a0c0e36404173d504b339a70",
          "showNotes": "The Primeagen is known for embracing controversy. He returns to the podcast for a conversation on a range of topics like masculinity, social media, and pornography. He also opens up about his father’s passing and his journey growing up with a single mother.\nMichael Paulson aka The Primeagen, Software Engineer at Netflix, is an influential figure in the tech community. He shares his thoughts on React's evolution and the impact it has on web applications and offers a behind-the-scenes look at the inner workings of Netflix and the problem-solving initiatives he led. He also discusses social media use and explains how he leverages platforms like Twitter, Twitch, and YouTube to express his thoughts while fostering an engaging online community.\nIn this episode, The Primeagen talks to Robbie and Chuck about his views on frameworks like React, the perils of pornography, and how he is saving Netflix millions of dollars.\nIn this episode:\n\n(00:00) - Welcome to Whiskey Web and Whatnot\n(01:39) - Introduction to The Primeagen\n(04:21) - A whiskey review - Spirits of French Lick William Dalton Single Barrel Bourbon\n(14:13) - Tech hot takes\n(44:49) - The Primeagen talks about limiting social media use\n(56:38) - What The Primeagen would do if he wasn’t in tech\n(01:02:25) - The Primeagen’s take on pornography\n(01:18:09) - The influence of The Primeagen's father's passing\n(01:21:48) - How The Primeagen saved Netflix millions of dollars\n\n\nQuotes\n[18:50] - “It feels like React, at this point, is in this state where it’s the industry standard, but I don’t feel like people are happy with it.” ~ The Primeagen\n[24:45] - “When people start relying on you as some sort of open source provider, you do still have some level of obligation.” ~ The Primeagen\n[35:26] - “The thing about Bun is that I really like it. It’s just not 1.0.” ~ The Primeagen\nLinks\n\nThe Primeagen YouTube\nThe Primeagen Twitter\nThe Primeagen Twitch\nThe Primeagen Instagram\nThePrimeTime\nPrime\nSpirits of French Lick William Dalton Single Barrel Bourbon\nStitzel-Weller Distillery\nPappy Van Winkle\nBubbalicious\nW.L. Weller Antique\nWindows\nApple\nXbox\nTwitter\nGoogle\nOracle\nReact\nSvelte\nHashiCorp\nDavid Heinemeier Hansson\nWarren Buffering\nRust\nVoodoo Doughnut\nNode JS\nBun\nChatGPT\nLinux\nVite\nAstro\nNetflix\nThe Dvorak Keyboard\nAmazon\nStadia\n\nConnect with Chuck and Robbie\n\nRobbie Wagner: https://x.com/RobbieTheWagner \nChuck Carpenter: https://x.com/CharlesWthe3rd \n\n\nSubscribe and stay in touch\n\nWebsite: https://whiskey.fm \nApple Podcasts: https://podcasts.apple.com/us/podcast/whiskey-web-and-whatnot/id1552776603 \nSpotify: https://open.spotify.com/show/19jiuHAqzeKnkleQUpZxDf \nOvercast: https://overcast.fm/itunes1552776603 \nYouTube: https://www.youtube.com/@WhiskeyWebAndWhatnot \n\n\nWhiskey Web and Whatnot Merch\nEnjoying the podcast and want us to make more? Help support us by picking up some of our fresh merch at https://whiskey.fund. \nSee Privacy Policy at https://art19.com/privacy and California Privacy Notice at https://art19.com/privacy#do-not-sell-my-info.",
          "itemLink": "https://art19.com/shows/whiskey-web-and-whatnot"
        }
      ]
    },
    {
      "feedTitle": "This Dot Labs RSS feed",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Custom Next.js Servers - Do you really need them?",
          "media": null,
          "showNotes": "If you stumbled upon this post, chances are you are either using custom servers in one of your Next.js projects or considering it. You may also just be curious about custom servers and whether you need them.\nIn either case, here are some things you should know about using custom servers in Next.js.\nWhat are custom servers?\nBy default, Next.js uses a built-in server to handle incoming requests, which automatically starts when you run next dev or next start. However, if you need more control — such as handling specialized routing patterns or implementing custom server-side behaviors — you have the option to create a custom server. This approach gives you the flexibility to programmatically manage request handling beyond what Next.js’s native routing offers.\nTo opt out of the default server, you need to create a server.js file in the root of your project and modify the package.json to use it:\n// package.json\n{\n  \"scripts\": {\n    \"dev\": \"node server.js\",\n    \"build\": \"next build\",\n    \"start\": \"NODE_ENV=production node server.js\"\n  }\n}\n\nA basic custom server implementation using the Node.js HTTP module for some custom routing might look like this:\n// server.js\nimport { createServer } from 'http'\nimport { parse } from 'url'\nimport next from 'next'\n\nconst port = parseInt(process.env.PORT || '3000', 10)\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  createServer((req, res) => {\n    const parsedUrl = parse(req.url!, true)\n\n    // Custom routing logic\n    if (parsedUrl.pathname === '/custom-route') {\n      app.render(req, res, '/specific-page', parsedUrl.query)\n      return\n    }\n\n    // Let Next.js handle all other routes\n    handle(req, res, parsedUrl)\n  }).listen(port)\n\n  console.log(\n    `> Server listening at http://localhost:${port} as ${\n dev ? 'development' : process.env.NODE_ENV\n    }`\n )\n})\n\nIn this example:\nWe create a Next.js app instance with next()\nWe get the request handler with app.getRequestHandler()\nWe create a custom HTTP server that intercepts requests to /custom-route\nFor that route, we render a specific page with custom query parameters\nNext.js's default handler handles all other routes\nAnd here's an example of a custom server implementation that uses Express.js:\n// server.js\nimport express from \"express\";\nimport next from \"next\";\n\nconst port = parseInt(process.env.PORT || \"3000\", 10);\nconst dev = process.env.NODE_ENV !== \"production\";\nconst app = next({ dev });\nconst handle = app.getRequestHandler();\n\napp.prepare().then(() => {\n  const server = express();\n\n  // Custom middleware\n  server.use((req, res, next) => {\n    console.log(`Request received: ${req.url}`);\n    next();\n  });\n\n  // Custom route handling\n  server.get(\"/custom-route/:id\", (req, res) => {\n    const { id } = req.params;\n    app.render(req, res, \"/product\", { id });\n  });\n\n  // API route\n  server.get(\"/api/custom\", (req, res) => {\n    res.json({ message: \"Custom API response\" });\n  });\n\n  // Default handler for all other routes\n  server.all(\"*\", (req, res) => {\n    return handle(req, res);\n  });\n\n  server.listen(port, (err) => {\n    if (err) throw err;\n    console.log(`> Ready on http://localhost:${port}`);\n  });\n});\n\nIn this Express.js example:\nWe create an Express server instance\nWe add custom middleware for logging requests\nWe define a parameterized route /custom-route/:id that renders a specific page\nWe create a custom API endpoint at /api/custom\nWe use a catch-all route to let Next.js handle all other routes\nCommon use cases for custom servers\nSome of the common reasons why people have used custom servers include:\nCustom Routing: Sometimes, you might want to implement custom routing logic beyond what Next.js's file-based routing offers, such as custom URL patterns and parameters or supporting legacy URL structures.\nRequest/Response Manipulation: Another reason is adding custom headers to responses or modifying request objects before they reach the application, such as implementing custom CORS policies.\nAuthentication and Authorization: Custom authentication flows can sometimes be implemented in a custom server, such as protecting routes based on user role or managing session state.\nWebSockets Support: If your application requires real-time communication, you might need to implement WebSockets support, e.g., chat applications or live notifications and updates. That has been one of the most common reasons for using custom servers.\nBackground Processing: If you're using logging tools such as New Relic, you might need to implement background processing to avoid blocking responses. This is where custom servers could be useful historically.\nProxying Requests: Having integration with external APIs or services, you might need a custom server to be able to forward requests to those APIs, implement API gateways, or avoid CORS issues with these third-party services.\nNon-HTTP Protocol Support: If your application needs to support protocols beyond HTTP and WebSockets that aren't supported by the Edge Runtime, having a custom server could be a solution.\nIntegration with Existing Systems: Embedding Next.js within larger applications, integrating with proprietary middleware, or working with legacy enterprise systems may require a custom server implementation.\nSpecialized Performance Requirements: Specific performance requirements, such as custom connection pooling or server-level caching strategies, may warrant a solution implemented in a custom server.\nMulti-Application Architectures: A custom server might be needed if you need to serve multiple Next.js applications from a single server with custom routing logic or implement application-level load balancing.\nCaveats and Considerations of Using Custom Servers\nYou should be aware of several important implications of using custom servers.\nPerformance Implications\nLoss of Automatic Static Optimization: Custom servers disable Next.js's automatic static optimization, forcing all pages to be server-rendered at runtime even if they could be statically generated. This can significantly impact performance and increase server load.\nIncreased TTFB (Time to First Byte): Without static optimization, Time to First Byte typically increases, affecting core web vitals and user experience.\nReduced Edge Caching Opportunities: Custom servers may interfere with CDN caching strategies that Next.js would otherwise optimize automatically.\nDeployment Limitations\nVercel Incompatibility: Custom servers cannot be deployed on Vercel, eliminating access to Vercel's optimized infrastructure for Next.js applications.\nServerless Deployment Challenges: Many serverless platforms are incompatible with custom server implementations, limiting deployment options.\nIncreased Infrastructure Requirements: Custom servers typically require traditional server infrastructure rather than more cost-effective serverless or edge options.\nMaintenance Challenges\nFramework Updates: Custom servers require manual updates when upgrading Next.js versions, as they operate outside the standard upgrade path.\nDivergence from Documentation: Most Next.js documentation assumes the standard server, making troubleshooting more difficult with custom implementations.\nKnowledge Transfer: Custom server implementations create additional onboarding challenges for new team members who must understand both Next.js and your custom server logic.\nCompatibility Issues\nFeature Incompatibility: Many Next.js features may not work as expected with custom servers, including:\nIncremental Static Regeneration (ISR)\nOn-demand Revalidation\nImage Optimization API\nMiddleware (in some configurations)\nStandalone Output Mode: Custom servers are incompatible with Next.js's standalone output mode, which is designed to optimize deployments.\nNext.js Compiler: Custom server files don't run through the Next.js compiler, requiring manual compatibility with your Node.js version.\nSecurity Considerations\nSecurity Updates: Custom servers may miss security improvements automatically applied to the standard Next.js server.\nManual Security Implementation: Security features like CORS, rate limiting, and request validation must be manually implemented and maintained.\nIncreased Attack Surface: Custom servers potentially introduce additional security vulnerabilities if not correctly configured and maintained.\nScaling Challenges\nManual Scaling Logic: Custom scaling logic must be implemented rather than leveraging platform-provided scaling for standard Next.js applications.\nResource Utilization: Custom servers often have less efficient resource utilization than the optimized standard Next.js server.\nGlobal Distribution Complexity: Implementing global distribution and edge presence becomes significantly more complex with custom servers.\nDevelopment Workflow Impacts\nDevelopment/Production Parity: Maintaining parity between development and production environments becomes more challenging.\nHot Module Replacement (HMR): Custom servers may interfere with Next.js's HMR capabilities, requiring manual configuration to maintain developer experience.\nDebugging Complexity: Debugging becomes more complex as issues could stem from either Next.js or the custom server implementation.\nMigration Difficulties\nLock-in Effect: Once implemented, migrating away from a custom server can be challenging as application logic becomes intertwined with server implementation.\nRefactoring Overhead: Significant refactoring may be required to move from a custom server to standard Next.js patterns.\nTechnical Debt: Custom servers often become sources of technical debt as Next.js evolves with new features that aren't compatible with custom implementations.\nWhy you might not need a custom server and how to migrate away from it\nThe performance and maintainability implications mentioned above provide a good incentive not to use custom servers and migrate away from them if you've used them in your project.\nConveniently, Next.js has evolved a lot recently, and many of the use cases mentioned above that historically required custom servers can now be addressed using built-in Next.js features. Here's how modern Next.js handles these scenarios without custom servers:\n1. Custom Routing → Dynamic Routes\nNext.js now provides comprehensive routing capabilities through its file-system-based router, which includes dynamic segments, catch-all routes, and optional catch-all routes.\nYou can use the following patterns to achieve most of the use cases that historically required custom servers:\napp/product/[id]/page.js         # Dynamic route\napp/[...slug]/page.js            # Catch-all route\napp/[[...optionalSlug]]/page.js  # Optional catch-all route\n\n2. Request/Response Manipulation → Middleware\nNext.js Middleware provides a standardized way to modify requests and responses before they reach your application.\nYou can easily implement custom headers, CORS, rate limiting, and more using middleware:\n// middleware.js\nexport function middleware(request) {\n  const response = NextResponse.next();\n  response.headers.set(\"X-Custom-Header\", \"value\");\n  return response;\n}\n\n3. Authentication → Middleware + Auth Libraries\nNext.js Middleware combined with authentication libraries like NextAuth.js provides a more maintainable and secure approach to authentication.\nInstead of using a custom server, you can implement authentication logic in middleware like this:\n// middleware.js\nexport function middleware(request) {\n  if (\n    !isAuthenticated(request) &&\n    request.nextUrl.pathname.startsWith(\"/dashboard\")\n ) {\n    return NextResponse.redirect(new URL(\"/login\", request.url));\n  }\n  return NextResponse.next();\n}\n\n4. WebSockets → Standalone WebSocket Server\nTo preserve Next.js optimizations, you can implement WebSockets without a custom server using a standalone WebSocket server approach. This is more compatible with modern deployment platforms and preserves Next.js optimizations.\nTo migrate away from a custom server, you can follow these steps:\n1. Create a Standalone WebSocket Server\nFirst, create a separate WebSocket server file:\n// ws-server.js\nconst { WebSocketServer } = require(\"ws\");\nconst { createServer } = require(\"http\");\nconst { parse } = require(\"url\");\n\n// Create HTTP server\nconst server = createServer();\nconst wss = new WebSocketServer({ noServer: true });\n\n// Handle WebSocket connections\nwss.on(\"connection\", (ws, request, client) => {\n  console.log(\"Client connected\");\n\n  // Store client information if needed\n  ws.userId = client.userId;\n\n  ws.on(\"message\", (message) => {\n    const data = JSON.parse(message.toString());\n    console.log(\"Received message:\", data);\n\n    // Broadcast to all clients\n    wss.clients.forEach((client) => {\n      if (client.readyState === ws.OPEN) {\n        client.send(\n          JSON.stringify({\n type: \"message\",\n id: Date.now().toString(),\n text: data.text,\n sender: ws.userId || \"Anonymous\",\n timestamp: new Date().toISOString(),\n          })\n );\n      }\n    });\n  });\n\n  ws.on(\"close\", () => {\n    console.log(\"Client disconnected\");\n  });\n});\n\n// Handle upgrade requests\nserver.on(\"upgrade\", (request, socket, head) => {\n  const { pathname, query } = parse(request.url, true);\n\n  // You can add authentication here\n  if (pathname === \"/api/ws\") {\n    // Extract user information from query or headers\n    const userId = query.userId || \"anonymous\";\n\n    wss.handleUpgrade(request, socket, head, (ws) => {\n      wss.emit(\"connection\", ws, request, { userId });\n    });\n  } else {\n    socket.destroy();\n  }\n});\n\n// Start server on a different port than Next.js\nserver.listen(3001, () => {\n  console.log(\"WebSocket server running on port 3001\");\n});\n\n2. Create a WebSocket Client Hook\n// hooks/use-websocket.ts\nimport { useState, useEffect, useRef, useCallback } from \"react\";\n\nexport function useWebSocket(url: string) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState<any[]>([]);\n  const socketRef = useRef<WebSocket | null>(null);\n\n  // Connect to WebSocket\n  useEffect(() => {\n    const socket = new WebSocket(url);\n    socketRef.current = socket;\n\n    socket.onopen = () => {\n      console.log(\"WebSocket connected\");\n      setIsConnected(true);\n    };\n\n    socket.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      setMessages((prev) => [...prev, data]);\n    };\n\n    socket.onclose = () => {\n      console.log(\"WebSocket disconnected\");\n      setIsConnected(false);\n    };\n\n    return () => {\n      socket.close();\n    };\n  }, [url]);\n\n  // Send message function\n  const sendMessage = useCallback((data: any) => {\n    if (socketRef.current?.readyState === WebSocket.OPEN) {\n      socketRef.current.send(JSON.stringify(data));\n    }\n  }, []);\n\n  return { isConnected, messages, sendMessage };\n}\n\n3. Update Your Next.js Application\n// app/page.tsx\n\"use client\";\n\nimport { useState, useEffect } from \"react\";\nimport { useWebSocket } from \"@/hooks/use-websocket\";\n\nexport default function ChatPage() {\n  const [username, setUsername] = useState(\"\");\n  const [message, setMessage] = useState(\"\");\n  const [hasJoined, setHasJoined] = useState(false);\n\n  // Determine WebSocket URL based on environment\n  const wsUrl =\n    process.env.NODE_ENV === \"production\"\n      ? `wss://${window.location.host}/api/ws?userId=${encodeURIComponent(\n username\n )}`\n      : `ws://localhost:3001/api/ws?userId=${encodeURIComponent(username)}`;\n\n  const { isConnected, messages, sendMessage } = useWebSocket(\n    hasJoined ? wsUrl : null\n );\n\n  const handleJoin = (e) => {\n    e.preventDefault();\n    if (username) setHasJoined(true);\n  };\n\n  const handleSendMessage = (e) => {\n    e.preventDefault();\n    if (message && isConnected) {\n      sendMessage({ type: \"message\", text: message });\n      setMessage(\"\");\n    }\n  };\n\n  // Rest of your component...\n}\n\n4. Configure Your Deployment\nFor production, you'll need to set up a proxy to forward WebSocket requests to your standalone server:\n// next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  async rewrites() {\n    return [\n      {\n source: \"/api/ws\",\n destination:\n          process.env.NODE_ENV === \"production\"\n            ? \"https://your-websocket-server.com/api/ws\"\n            : \"http://localhost:3001/api/ws\",\n      },\n ];\n  },\n};\n\nmodule.exports = nextConfig;\n\n5. Update Your Package Scripts\n{\n  \"scripts\": {\n    \"dev\": \"concurrently \\\"next dev\\\" \\\"node ws-server.js\\\"\",\n    \"build\": \"next build\",\n    \"start\": \"next start\"\n  },\n  \"dependencies\": {\n    \"concurrently\": \"^8.0.1\",\n    \"ws\": \"^8.13.0\"\n  }\n}\n\nThis approach gives you the best of both worlds: Next.js's optimized rendering and routing with the real-time capabilities of WebSockets, all without sacrificing deployment options or performance.\n5. Background Processing → unstable_after API\nThe new unstable_after API in Next.js 15 allows for background processing after a response has been sent.\nInstead of using a custom server, you can use this API to execute code after a response has been sent:\n// middleware.js\nimport { unstable_after as after } from \"next/server\";\n\nexport function middleware(request) {\n  const response = NextResponse.next();\n  after(async () => {\n    await logRequest(request);\n  });\n  return response;\n}\n\nPlease note that this API is experimental and not yet stable, so it's important to watch the Next.js blog for updates.\n6. Proxying Requests → Rewrites\nNext.js config rewrites provide a declarative way to proxy requests without custom server code.\nTo proxy requests to an external API, you can use the following configuration, eliminating the need for a custom server:\n// next.config.js\nmodule.exports = {\n  async rewrites() {\n    return [\n      {\n source: \"/api/external/:path*\",\n destination: \"https://external-api.com/:path*\",\n      },\n ];\n  },\n};\n\nUse Cases That May Still Require Custom Servers\nWhile a lot of use cases that historically required custom servers can now be addressed by fully leveraging modern Next.js features, there are still some scenarios that may require a custom server implementation:\nNon-HTTP Protocol Support: When your application needs to support protocols beyond HTTP and WebSockets, you might still need a custom server.\nDeep Integration with Existing Systems: A custom server may be required for scenarios requiring tight integration with existing non-Node.js systems where the integration point must be at the server level.\nHighly Specialized Performance Requirements: A custom server may be needed for applications with extremely specific performance needs that can't be addressed through Next.js's built-in optimizations.\nComplex Multi-Application Architectures: When building complex architectures that don't fit the standard Next.js model and require custom orchestration at the server level, you might not be able to avoid a custom server.\nWhat to do if you need a custom server\nFollow best practices! That means if a custom server is absolutely necessary for your use case:\nMinimize Custom Logic: Keep custom server logic to an absolute minimum.\nIsolate Custom Code: Clearly separate custom server code from Next.js application code.\nDocument Thoroughly: Maintain detailed documentation explaining why the custom server is necessary and how it works.\nRegular Reassessment: Periodically reassess whether the custom server is still necessary as Next.js evolves.\nMonitoring: Implement comprehensive monitoring to quickly identify performance or stability issues related to the custom server.\nConclusion\nCustom servers are a powerful tool that can address specific use cases that are not easily solved with modern Next.js features. However, they come with significant trade-offs in performance, deployment options, maintenance overhead, and compatibility with Next.js features.\nBefore implementing a custom server, thoroughly evaluate whether modern Next.js features like middleware, API routes, and rewrites can address your requirements without the drawbacks of a custom server implementation.\nIf you already have a custom server implemented, consider migrating to modern Next.js features if your use case can be addressed with them, as it will likely bring more benefits than drawbacks.",
          "itemLink": "https://www.thisdot.co/blog/custom-next-js-servers-do-you-really-need-them"
        }
      ]
    },
    {
      "feedTitle": "ShopTalk",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "674: Context in Console, CodePen’s New Editor, and Looking for a New Arc",
          "media": "https://shoptalkshow.com/podcast-download/8304/674.mp3?nocache",
          "showNotes": "Show Description\nDave's coming in hot from vacation, how CodePen's new editor imports packages, should CodePen fix your code if you forgot something, the struggle to get the right context in the console, Chris is still shopping for an Arc replacement, and the struggles with inspiration driven engineering.\n(20% discount code for the Design Tokens Course: SHOPTALKSHOWISAWESOME)\nListen on Website →\nLinks\n\nOrion Browser by Kagi\nMeet Dia \nChrome Canary\nSigmaOS\nMythic Quest - Wikipedia\nSponsors\nDesign Tokens Course\nWorld-renowned design systems experts Brad Frost (creator of Atomic Design) and Ian Frost teach you everything you need to know about creating an effective design token system to help your organization design and build at scale.",
          "itemLink": "https://shoptalkshow.com/674/"
        }
      ]
    },
    {
      "feedTitle": "Soft Skills Engineering",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Episode 470: I said something stupid in a meeting and just want to code",
          "media": "https://dts.podtrac.com/redirect.mp3/download.softskills.audio/sse-470.mp3?source=rss",
          "showNotes": "In this episode, Dave and Jamison answer these questions:\nI was on a meeting with a team generally regarded to be pretty annoying to deal with and not particularly useful. The meeting was pretty annoying and not particularly useful. I audibly said to myself after leaving “holy crap what a waste of time.” Turns out I hadn’t left and may not have been muted (?) but I’m really not sure. I left immediately without checking due to cringe overload, so I have no way of knowing.\nHow do I even go about this? I have to meet with this team regularly. My spirit has left my body, this question was typed by the husk that remained.\nI am almost 2 years into my software development career. A few months ago, I was moved to a team where I was the only frontend developer. My team responsible for maintaining a large, legacy angular project and building a new internal in React tool to support the ML engineers at our organization. Our organization hired some contractors to help with building the new tool, all of which have the same or less dev experience as me.\nOur project manager is not engaged in our project. He is on multiple teams. I have to communicate with our customer, gather requirements, create user stories, and QA the contractors’ work. This is not the type of work I am particularly good at or enjoy. This is on top of me being the de-facto frontend tech lead. I am STRUGGLING to keep up. I can only do a little bit of work on our project each iteration and doing required maintenance of the legacy application has become very difficult to do because of how little attention I am able to give it.\nI don’t want to do all the other stuff, I just want to write code. What should I do?",
          "itemLink": "https://softskills.audio/2025/07/21/episode-470-i-said-something-stupid-in-a-meeting-and-just-want-to-code/"
        }
      ]
    },
    {
      "feedTitle": "Front-End Fire",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Windsurf’s 72-Hour Power Shuffle",
          "media": "https://www.buzzsprout.com/2226499/episodes/17536060-windsurf-s-72-hour-power-shuffle.mp3",
          "showNotes": "There are so many headlines about AI IDE Windsurf as of late, but we’ll try to catch you up. \nFirst, OpenAI wanted to buy Windsurf for $3B, but the deal fell through due to Microsoft. Next, Google hired Windsurf’s top execs and researchers to work on its AI products, but didn’t buy the Windsurf IDE, for $2.4B. Then, Cognition bought the remainder of Windsurf’s IP (and its staff) to integrate into its own products like Devin. And did we mention this all happened in the span of 72 hours?\nAmazon released its own AI-powered IDE called Kiro, and it claims it will bring structure to vibe-coding with \"specs\" to appeal to the enterprise companies. Kiro transforms prompts into structured specifications, technical designs, and implementation plans complete with testing.\nNext.js 15.4 debuted with a few notable highlights like 100% integration test compatibility for its new Turbopack bundler, and an experimental feature flag called `browserDebugInfoInTerminal` that will forward browser console output to the local terminal so CLI coding agents and AI IDEs like Cursor can see (and fix) client side errors. That sounds super useful.\nTimestamps:\n\n1:07 - Windsurf drama explained\n11:28 - Amazon’s new Kiro editor\n26:29 - Next 15.4\n33:33 - Figma’s new glass effect\n39:19 - Lee Robinson leaves Vercel\n41:09 - What’s making us happy\n\nLinks:\n\nPaige - Next.js 15.4, including `browserDebugInfoInTerminal` flag for AI agents\nJack - Kiro AI IDE for spec-driven development\nTJ - OpenAI’s Windsurf deal falls through - and Windsurf’s CEO is going to Google\nLee Robinson leaves Vercel after 5 years\nFigma has Glass Effect\nPaige - The Will of the Many novel\nJack - Ninja Single Serve coffee maker and SF Bay Coffee compostable K-cups\nTJ - Tabletop shuffleboard\n\nThanks as always to our sponsor, the Blue Collar Coder channel on YouTube. You can join us in our Discord channel, explore our website and reach us via email, or talk to us on X, Bluesky, or YouTube.\n\nFront-end Fire website\nBlue Collar Coder on YouTube\nBlue Collar Coder on Discord\nReach out via email\nTweet at us on X @front_end_fire\nFollow us on Bluesky @front-end-fire.com\nSubscribe to our YouTube channel @Front-EndFirePodcast",
          "itemLink": "https://www.buzzsprout.com/2226499"
        }
      ]
    },
    {
      "feedTitle": "Modern Web",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Indie Bites",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "devtools.fm: Developer Tools, Open Source, Software Development",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "DevTalles",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "220 - Migraciones de base de datos",
          "media": "https://anchor.fm/s/4c227378/podcast/play/105984403/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2025-6-25%2Fa35231f6-a82c-a885-0206-1e0303cf6f37.mp3",
          "showNotes": "En este episodio hablamos sobre migraciones de base de datos: cuándo usarlas, buenas prácticas, errores comunes y hasta cuándo no vale la pena complicarse con ellas. Un repaso completo para que tu base no se vuelva un caos silencioso.",
          "itemLink": "https://podcasters.spotify.com/pod/show/fernando-her85/episodes/220---Migraciones-de-base-de-datos-e360suj"
        }
      ]
    },
    {
      "feedTitle": "HTTP 203",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Frontend First",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Svelte Radio",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "JS Party: JavaScript, CSS, Web Development",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "PodRocket - A web development podcast from LogRocket",
      "updateStatus": 2,
      "data": [
        {
          "itemTitle": "How Lingo.dev is reimagining i18n in React with Max Prilutskiy",
          "media": "https://dts.podtrac.com/redirect.mp3/aphid.fireside.fm/d/1437767933/3911462c-bca2-48c2-9103-610ba304c673/faf6167d-9ae3-4ff6-948e-34c37f25d46a.mp3",
          "showNotes": "Max Prilutskiy, co-founder and CEO of lingo.dev, about the lingo.dev compiler, a powerful open-source tool that automates multilingual support in React applications. Max dives deep into how the compiler uses ASTs and AI to eliminate the traditional friction of i18n workflows, offers build-time translations, and supports hot module replacement, static builds, and frameworks like Vite, Next.js, and React Router.\nLinks\nLinkedIn: https://www.linkedin.com/in/maxprilutskiy\nWebsite: https://maxprilutskiy.com\nX: https://x.com/maxprilutskiy\nGithub: https://github.com/maxprilutskiy\nResources\nhttps://lingo.dev/en/compiler\nWe want to hear from you!\nHow did you find us? Did you see us on Twitter? In a newsletter? Or maybe we were recommended by a friend?\nLet us know by sending an email to our producer, Em, at emily.kochanek@logrocket.com (mailto:emily.kochanek@logrocket.com), or tweet at us at PodRocketPod (https://twitter.com/PodRocketpod).\nFollow us. Get free stickers.\nFollow us on Apple Podcasts, fill out this form (https://podrocket.logrocket.com/get-podrocket-stickers), and we’ll send you free PodRocket stickers!\nWhat does LogRocket do?\nLogRocket provides AI-first session replay and analytics that surfaces the UX and technical issues impacting user experiences. Start understanding where your users are struggling by trying it for free at LogRocket.com. Try LogRocket for free today. (https://logrocket.com/signup/?pdr) Special Guest: Max Prilutskiy.",
          "itemLink": "http://podrocket.logrocket.com/how-lingo-dev-reimagining-i18n-in-react-max-prilutskiy"
        },
        {
          "itemTitle": "Goodbye, useState with David Khourshid",
          "media": "https://dts.podtrac.com/redirect.mp3/aphid.fireside.fm/d/1437767933/3911462c-bca2-48c2-9103-610ba304c673/4867afc3-f559-48b2-9f31-a7e523d752b9.mp3",
          "showNotes": "David Khourshid, founder of Stately.ai, joins us to discuss better ways to manage complex state in React applications. We explore the pitfalls of overusing useState, how discriminated unions and state machines improve app logic, the role of server components, and the growing importance of query strings and persistent state management. He also shares insights on modern third-party libraries, React’s missing \"store\" primitive, and when developers should rethink their entire approach to state modeling.\nLinks\nX: https://x.com/DavidKPiano\nGithub: https://github.com/davidkpiano\nLinkedIn: https://www.linkedin.com/in/davidkpiano/\nResources\nReact Miami talk: https://www.youtube.com/watch?v=d3mhZbBOxbE\nWe want to hear from you!\nHow did you find us? Did you see us on Twitter? In a newsletter? Or maybe we were recommended by a friend?\nLet us know by sending an email to our producer, Em, at emily.kochanek@logrocket.com (mailto:emily.kochanek@logrocket.com), or tweet at us at PodRocketPod (https://twitter.com/PodRocketpod).\nFollow us. Get free stickers.\nFollow us on Apple Podcasts, fill out this form (https://podrocket.logrocket.com/get-podrocket-stickers), and we’ll send you free PodRocket stickers!\nWhat does LogRocket do?\nLogRocket provides AI-first session replay and analytics that surfaces the UX and technical issues impacting user experiences. Start understanding where your users are struggling by trying it for free at LogRocket.com. Try LogRocket for free today. (https://logrocket.com/signup/?pdr) Special Guest: David Khourshid.",
          "itemLink": "http://podrocket.logrocket.com/goodbye-use-state-david-khourshid"
        }
      ]
    },
    {
      "feedTitle": "Web Rush",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Jamstack Radio",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "JavaScript Jabber",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Preact, Performance, and the Future of Lightweight Frontends with Ryan Christian -JSJ 683",
          "media": "https://dts.podtrac.com/redirect.mp3/api.spreaker.com/download/episode/67089686/jsj_683.mp3",
          "showNotes": "In this episode of JavaScript Jabber, we sit down with Ryan Christian, a core maintainer of Preact, to talk all things lightweight, performant, and practical in the JavaScript world. If you’ve ever wondered what makes Preact tick, why it continues to gain traction, and how it compares to the heavyweight champ React—this episode is for you.\nWe get into the nitty-gritty of what separates Preact from React, not just in size but in philosophy. Ryan sheds light on how Preact is engineered for performance, why it's not just a “React clone,” and how its compatibility layer makes it easy to drop into existing projects. Plus, we explore signals, class components, and what the upcoming Preact v11 has in store.\nEpisode Highlights\n[1:23] - Meet Ryan Christian: Preact core maintainer and open-source champion\n[4:10] - What is Preact, and how does it stack up against React?\n[10:15] - Preact’s tiny footprint and why size still matters\n[14:47] - Widgets, adoption, and why Preact powers ~6% of major sites\n[20:01] - Understanding Preact’s compatibility layer (PreactCompat)\n[25:40] - Hooks, signals, and modularity: build what you need, nothing more\n[31:10] - Why Preact won’t follow React into full-stack territory\n[37:22] - Server components, suspense, and what Ryan recommends instead\n[43:35] - Frameworks that pair well with Preact: Astro, Fresh, and Remix\n[47:55] - Sneak peek at Preact v11 and why it sticks with “classic” React experience\n🔗 Links & Resources\nPreact Official Website\nAstro\nFresh by Deno\nRemix\nJason Miller’s VTalk on Signals (referenced)\nGoogle CrUX Report – for framework usage stats\n\nBecome a supporter of this podcast: https://www.spreaker.com/podcast/javascript-jabber--6102064/support.",
          "itemLink": "https://www.spreaker.com/episode/preact-performance-and-the-future-of-lightweight-frontends-with-ryan-christian-jsj-683--67089686"
        }
      ]
    },
    {
      "feedTitle": "DejaVue",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Syntax - Tasty Web Development Treats",
      "updateStatus": 2,
      "data": [
        {
          "itemTitle": "922: Pre-commit Hooks, requestAnimationFrame, Code Reviews, and More",
          "media": "https://traffic.megaphone.fm/FSI7346366235.mp3?updated=1752950196",
          "showNotes": "In this potluck episode of Syntax, Wes and Scott answer your questions about code reviews, migrating legacy apps, CSS attr() use cases, pre-commit hooks, the future of creative web development, whether front-end devs need to be full-stack, and more!\n\nShow Notes\n\n\n  \n00:00 Welcome to Syntax!\n\n  \n00:43 When is the appropriate time to use requestAnimationFrame?\n\n  \n05:10 How do you handle code reviews on larger teams?\n\n  \n13:08 When to use the CSS attr() function\n\n  \n19:01 The future of browsing websites and the impact of AI\n\n  \n28:45 Brought to you by Sentry.io\n\n\n  \n29:10 Navigating browser preview in VS Code\n\n  \n31:31 Pre-populating email content with mailto\n\n  \n34:29 Is there increasing pressure for front-end developers to become full-stack?\n\n  \n43:14 What pre-commit checks should you run and how?\n\n  \n46:16 How do you deal with a poorly-built codebase when you already have thousands of active users?\n\n  \n50:05 What GitHub Copilot features should you disable while you’re learning something new?\n\n  \n52:22 Sick Picks + Shameless Plugs\n\n\nSick Picks\n\n\n  Scott: WOLFBOX MF100 Electric Air Duster\n\n\n  Wes: Competition Kettlebells\n\n\n\nShameless Plugs\n\n\n  Syntax YouTube Channel\n\n\nHit us up on Socials!\n\nSyntax: X Instagram Tiktok LinkedIn Threads\n\nWes: X Instagram Tiktok LinkedIn Threads\n\nScott: X Instagram Tiktok LinkedIn Threads\n\nRandy: X Instagram YouTube Threads",
          "itemLink": "https://syntax.fm"
        },
        {
          "itemTitle": "921: AI Coding Roadmap for Newbies (And Skeptics)",
          "media": "https://traffic.megaphone.fm/FSI9048759391.mp3?updated=1752683451",
          "showNotes": "Scott and Wes break down how to code with and for AI; perfect for skeptics, beginners, and curious devs. They cover everything from Ghost Text and CLI agents to building your own AI-powered apps with embeddings, function calling, and multi-model workflows.\n\n\nShow Notes\n\n\n\n00:00 Welcome to Syntax!\n\n\n03:56 How to interface with AI.\n\n\n04:07 IDE Ghost Text.\n\n\n05:45 IDE Chat, Agents.\n\n\n08:00 CLI Agents.\n\n\nClaude Code.\n\n\nOpen Code.\n\n\nGemini.\n\n\n\n\n\n11:13 MCP Servers.\nContext7\n\n\n\n14:47 GUI apps.\n\n\nv0.\n\n\nBolt.new.\n\n\nLovable.\n\n\nWindsurf.\n\n\n\n\n\n19:07 Existing Chat app like ChatGPT.\n\n\n\n\n\n22:37 Building things WITH AI.\n\n\n23:32 Prompting.\n\n\n26:53 Streaming VS not streaming.\n\n\n28:14 Embeddings and Rag.\n\n\n31:09 MCP Server.\n\n\nCJ’s MCP Deep Dive.\n\n\n32:36 Brought to you by Sentry.io.\n\n\n\n\n\n33:25 Multi-model, multi-provider.\n\n\n36:27 npm libs to use to code with AI.\n\n\nOpenAI SDK.\n\n\nAI SDK.\n\n\nCloudflare Agents.\n\n\nLangchain.\n\nLocal AI\n\n\nTensorflow.\n\n\nTransformers.js.\n\n\nHuggingface.\n\n\n\n\n\n\n\n\n\n\n\n44:12 Processes and exploring.\n\n\n\nHit us up on Socials!\n\nSyntax: X Instagram Tiktok LinkedIn Threads\n\nWes: X Instagram Tiktok LinkedIn Threads\n\nScott: X Instagram Tiktok LinkedIn Threads\n\nRandy: X Instagram YouTube Threads",
          "itemLink": "https://syntax.fm/921"
        }
      ]
    },
    {
      "feedTitle": "Rust Review",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Front End Happy Hour",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Off The Main Thread",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "The CSS Podcast",
      "updateStatus": 0,
      "data": []
    }
  ]
}