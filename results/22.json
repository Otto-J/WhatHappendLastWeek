{
  "startOfWeek": "2025-05-26",
  "weekNumber": 22,
  "availableItems": 11,
  "results": [
    {
      "feedTitle": "Whiskey Web and Whatnot: Web Development, Neat",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "The Myth of Perfect Code w/ Marc Backes",
          "media": "https://rss.art19.com/episodes/44535030-2888-42a8-926c-d03a9a6aef2c.mp3?rss_browser=BAhJIg9yc3MtcGFyc2VyBjoGRVQ%3D--42d668516e215326a0c0e36404173d504b339a70",
          "showNotes": "This week, Robbie and Chuck talk with Marc Backes about Vue vs. React, work-life balance, and the realities of messy codebases. They also sip an Evan Williams Single Barrel, debate inbox zero, and discuss Marc’s adventures in coffee roasting and pilot training.\nIn this episode:\n\n(00:00) - Intro\n(01:45) - Whiskey review and rating: Evan Williams Single Barrel\n(09:03) - Hot Take: Inferred types vs explicit types\n(10:04) - Hot Take: Tailwind vs vanilla CSS\n(10:59) - Hot Take: Git Rebase vs Git Merge\n(11:27) - Nested ternaries?\n(15:58) - Real code vs ideal code\n(21:43) - Why work/life balance matters\n(30:28) - Why Marc chose Vue over React\n(31:19) - Ryan Reynolds speaking at Post/Con\n(32:40) - Render Atlanta and upcoming conferences\n(33:48) - Marc's connection to Mexico\n(34:54) - Discussing different foods\n(37:09) - Marc's inbox zero strategy\n(40:26) - Learning to fly\n(44:06) - Roasting coffee as a hobby\n(46:13) - Personal branding and standing out\n(51:19) - Plugs\n\nLinks\n\nEvan Williams Single Barrel: https://evanwilliams.com/single-barrel\nVue: https://vuejs.org/\nNuxt: https://nuxt.com/\nNorlan: https://norlanglass.com/\nNintendo: https://www.nintendo.com/\nSwitch 2: https://www.nintendo.com/us/gaming-systems/switch-2/\nDouble Double Oaked Woodford: https://www.woodfordreserve.com/whiskey/double-double-oaked/\nTypescript: https://www.typescriptlang.org/\nTailwind CSS: https://tailwindcss.com/\nReact: https://react.dev/\njQuery: https://jquery.com/\nRyan Reynolds: https://en.wikipedia.org/wiki/Ryan_Reynolds\nPost Con: https://postcon.postman.com/\nAviation Gin: https://www.aviationgin.com/\nMint Mobile: https://www.mintmobile.com/\nRender Conf: https://www.renderatl.com/\nTaco Bell: https://www.tacobell.com/\nMarc Backes - Achieving Inbox Zero: https://marc.dev/blog/inbox-zero\nSuperhuman: https://superhuman.com/\nVim: https://www.vim.org/\nVue: https://vuejs.org/\nVite: https://vite.dev/\nTerminal Coffee: https://www.terminal.shop/\nDax: https://x.com/thdxr/\nJack Daniel's: https://www.jackdaniels.com/\nKelly Vaughn: https://x.com/kvlly\n\nConnect with Marc\n\nWebsite: https://marc.dev/\nX / Twitter: https://x.com/themarcba\n\nConnect with Chuck and Robbie\n\nRobbie Wagner: https://x.com/RobbieTheWagner\nChuck Carpenter: https://x.com/CharlesWthe3rd\n\nSubscribe and stay in touch\n\nWebsite: https://whiskey.fm\nApple Podcasts: https://podcasts.apple.com/us/podcast/whiskey-web-and-whatnot/id1552776603\nSpotify: https://open.spotify.com/show/19jiuHAqzeKnkleQUpZxDf\nOvercast: https://overcast.fm/itunes1552776603\nYouTube: https://www.youtube.com/@WhiskeyWebAndWhatnot\n\nWhiskey Web and Whatnot Merch\nEnjoying the podcast and want us to make more? Help support us by picking up some of our fresh merch at https://whiskey.fund.\nSee Privacy Policy at https://art19.com/privacy and California Privacy Notice at https://art19.com/privacy#do-not-sell-my-info.",
          "itemLink": "https://art19.com/shows/whiskey-web-and-whatnot"
        }
      ]
    },
    {
      "feedTitle": "This Dot Labs RSS feed",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Next.js Rendering Strategies and how they affect core web vitals",
          "media": null,
          "showNotes": "When it comes to building fast and scalable web apps with Next.js, it’s important to understand how rendering works, especially with the App Router. Next.js organizes rendering around two main environments: the server and the client. On the server side, you’ll encounter three key strategies: Static Rendering, Dynamic Rendering, and Streaming. Each one comes with its own set of trade-offs and performance benefits, so knowing when to use which is crucial for delivering a great user experience.\nIn this post, we'll break down each strategy, what it's good for, and how it impacts your site's performance, especially Core Web Vitals. We'll also explore hybrid approaches and provide practical guidance on choosing the right strategy for your use case.\nWhat Are Core Web Vitals?\nCore Web Vitals are a set of metrics defined by Google that measure real-world user experience on websites. These metrics play a major role in search engine rankings and directly affect how users perceive the speed and smoothness of your site.\nLargest Contentful Paint (LCP): This measures loading performance. It calculates the time taken for the largest visible content element to render. A good LCP is 2.5 seconds or less.\nInteraction to Next Paint (INP): This measures responsiveness to user input. A good INP is 200 milliseconds or less.\nCumulative Layout Shift (CLS): This measures the visual stability of the page. It quantifies layout instability during load. A good CLS is 0.1 or less.\nIf you want to dive deeper into Core Web Vitals and understand more about their impact on your website's performance, I recommend reading this detailed guide on  New Core Web Vitals and How They Work.\nNext.js Rendering Strategies and Core Web Vitals\nLet's explore each rendering strategy in detail:\n1. Static Rendering (Server Rendering Strategy)\nStatic Rendering is the default for Server Components in Next.js. With this approach, components are rendered at build time (or during revalidation), and the resulting HTML is reused for each request. This pre-rendering happens on the server, not in the user's browser. Static rendering is ideal for routes where the data is not personalized to the user, and this makes it suitable for:\nContent-focused websites: Blogs, documentation, marketing pages\nE-commerce product listings: When product details don't change frequently\nSEO-critical pages: When search engine visibility is a priority\nHigh-traffic pages: When you want to minimize server load\nHow Static Rendering Affects Core Web Vitals\nLargest Contentful Paint (LCP): Static rendering typically leads to excellent LCP scores (typically < 1s). The Pre-rendered HTML can be cached and delivered instantly from CDNs, resulting in very fast delivery of the initial content, including the largest element. Also, there is no waiting for data fetching or rendering on the client.\nInteraction to Next Paint (INP): Static rendering provides a good foundation for INP, but doesn't guarantee optimal performance (typically ranges from 50-150 ms depending on implementation). While Server Components don't require hydration, any Client Components within the page still need JavaScript to become interactive. To achieve a very good INP score, you will need to make sure the Client Components within the page is minimal.\nCumulative Layout Shift (CLS): While static rendering delivers the complete page structure upfront which can be very beneficial for CLS, achieving excellent CLS requires additional optimization strategies:\nStatic HTML alone doesn't prevent layout shifts if resources load asynchronously\nImage dimensions must be properly specified to reserve space before the image loads\nWeb fonts can cause text to reflow if not handled properly with font display strategies\nDynamically injected content (ads, embeds, lazy-loaded elements) can disrupt layout stability\nCSS implementation significantly impacts CLS—immediate availability of styling information helps maintain visual stability\nCode Examples:\nBasic static rendering:\n// app/page.tsx (Server Component - Static Rendering by default)\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/static-data');\n  const data = await res.json();\n  return (\n    <div>\n      <h1>Static Content</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\nStatic rendering with revalidation (ISR):\n// app/dashboard/page.tsx\nexport default async function Dashboard() {\n  // Static data that revalidates every day\n  const siteStats = await fetch('https://api.example.com/site-stats', {\n    next: { revalidate: 86400 } // 24 hours\n  }).then(r => r.json());\n\n  // Data that revalidates every hour\n  const popularProducts = await fetch('https://api.example.com/popular-products', {\n    next: { revalidate: 3600 } // 1 hour\n  }).then(r => r.json());\n\n  // Data with a cache tag for on-demand revalidation\n  const featuredContent = await fetch('https://api.example.com/featured-content', {\n    next: { tags: ['featured'] }\n  }).then(r => r.json());\n\n  return (\n    <div className=\"dashboard\">\n      <section className=\"stats\">\n        <h2>Site Statistics</h2>\n        <p>Total Users: {siteStats.totalUsers}</p>\n        <p>Total Orders: {siteStats.totalOrders}</p>\n      </section>\n\n      <section className=\"popular\">\n        <h2>Popular Products</h2>\n        <ul>\n          {popularProducts.map(product => (\n            <li key={product.id}>{product.name} - {product.sales} sold</li>\n          ))}\n        </ul>\n      </section>\n\n      <section className=\"featured\">\n        <h2>Featured Content</h2>\n        <div>{featuredContent.html}</div>\n      </section>\n    </div>\n  );\n}\n\nStatic path generation:\n// app/products/[id]/page.tsx\nexport async function generateStaticParams() {\n  const products = await fetch('https://api.example.com/products').then(r => r.json());\n\n  return products.map((product) => ({\n    id: product.id.toString(),\n  }));\n}\n\nexport default async function Product({ params }) {\n  const product = await fetch(`https://api.example.com/products/${params.id}`).then(r => r.json());\n\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>${product.price.toFixed(2)}</p>\n      <p>{product.description}</p>\n    </div>\n  );\n}\n\n2. Dynamic Rendering (Server Rendering Strategy)\nDynamic Rendering generates HTML on the server for each request at request time. Unlike static rendering, the content is not pre-rendered or cached but freshly generated for each user. This kind of rendering works best for:\nPersonalized content: User dashboards, account pages\nReal-time data: Stock prices, live sports scores\nRequest-specific information: Pages that use cookies, headers, or search parameters\nFrequently changing data: Content that needs to be up-to-date on every request\nHow Dynamic Rendering Affects Core Web Vitals\nLargest Contentful Paint (LCP): With dynamic rendering, the server needs to generate HTML for each request, and that can't be fully cached at the CDN level. It is still faster than client-side rendering as HTML is generated on the server.\nInteraction to Next Paint (INP): The performance is similar to static rendering once the page is loaded. However, it can become slower if the dynamic content includes many Client Components.\nCumulative Layout Shift (CLS): Dynamic rendering can potentially introduce CLS if the data fetched at request time significantly alters the layout of the page compared to a static structure. However, if the layout is stable and the dynamic content size fits within predefined areas, the CLS can be managed effectively.\nCode Examples:\nExplicit dynamic rendering:\n// app/dashboard/page.tsx\nexport const dynamic = 'force-dynamic'; // Force this route to be dynamically rendered\n\nexport default async function Dashboard() {\n  // This will run on every request\n  const data = await fetch('https://api.example.com/dashboard-data').then(r => r.json());\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <p>Last updated: {new Date().toLocaleString()}</p>\n      {/* Dashboard content */}\n    </div>\n  );\n}\n\nSimplicit dynamic rendering with cookies:\n// app/profile/page.tsx\nimport { cookies } from 'next/headers';\n\nexport default async function Profile() {\n  // Using cookies() automatically opts into dynamic rendering\n  const userId = cookies().get('userId')?.value;\n\n  const user = await fetch(`https://api.example.com/users/${userId}`).then(r => r.json());\n\n  return (\n    <div>\n      <h1>Welcome, {user.name}</h1>\n      <p>Email: {user.email}</p>\n      {/* Profile content */}\n    </div>\n  );\n}\n\nDynamic routes:\n// app/blog/[slug]/page.tsx\nexport default async function BlogPost({ params }) {\n  // It will run at request time for any slug not explicitly pre-rendered\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div>{post.content}</div>\n    </article>\n  );\n}\n\n3. Streaming (Server Rendering Strategy)\nStreaming allows you to progressively render UI from the server. Instead of waiting for all the data to be ready before sending any HTML, the server sends chunks of HTML as they become available. This is implemented using React's Suspense boundary.\nReact Suspense works by creating boundaries in your component tree that can \"suspend\" rendering while waiting for asynchronous operations. When a component inside a Suspense boundary throws a promise (which happens automatically with data fetching in React Server Components), React pauses rendering of that component and its children, renders the fallback UI specified in the Suspense component, continues rendering other parts of the page outside this boundary, and eventually resumes and replaces the fallback with the actual component once the promise resolves.\nWhen streaming, this mechanism allows the server to send the initial HTML with fallbacks for suspended components while continuing to process suspended components in the background. The server then streams additional HTML chunks as each suspended component resolves, including instructions for the browser to seamlessly replace fallbacks with final content. It works well for:\nPages with mixed data requirements: Some fast, some slow data sources\nImproving perceived performance: Show users something quickly while slower parts load\nComplex dashboards: Different widgets have different loading times\nHandling slow APIs: Prevent slow third-party services from blocking the entire page\nHow Streaming Affects Core Web Vitals\nLargest Contentful Paint (LCP): Streaming can improve the perceived LCP. By sending the initial HTML content quickly, including potentially the largest element, the browser can render it sooner. Even if other parts of the page are still loading, the user sees the main content faster.\nInteraction to Next Paint (INP): Streaming can contribute to a better INP. When used with React's &lt;Suspense />, interactive elements in the faster-loading parts of the page can become interactive earlier, even while other components are still being streamed in. This allows users to engage with the page sooner.\nCumulative Layout Shift (CLS): Streaming can cause layout shifts as new content streams in. However, when implemented carefully, streaming should not negatively impact CLS. The initially streamed content should establish the main layout, and subsequent streamed chunks should ideally fit within this structure without causing significant reflows or layout shifts. Using placeholders and ensuring dimensions are known can help prevent CLS.\nCode Examples:\nBasic Streaming with Suspense:\n// app/dashboard/page.tsx\nimport { Suspense } from 'react';\nimport UserProfile from './components/UserProfile';\nimport RecentActivity from './components/RecentActivity';\nimport PopularPosts from './components/PopularPosts';\n\nexport default function Dashboard() {\n  return (\n    <div className=\"dashboard\">\n      {/* This loads quickly */}\n      <h1>Dashboard</h1>\n\n      {/* User profile loads first */}\n      <Suspense fallback={<div className=\"skeleton-profile\">Loading profile...</div>}>\n        <UserProfile />\n      </Suspense>\n\n      {/* Recent activity might take longer */}\n      <Suspense fallback={<div className=\"skeleton-activity\">Loading activity...</div>}>\n        <RecentActivity />\n      </Suspense>\n\n      {/* Popular posts might be the slowest */}\n      <Suspense fallback={<div className=\"skeleton-posts\">Loading popular posts...</div>}>\n        <PopularPosts />\n      </Suspense>\n    </div>\n  );\n}\n\nNested Suspense boundaries for more granular control:\n// app/complex-page/page.tsx\nimport { Suspense } from 'react';\n\nexport default function ComplexPage() {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <Header />\n\n      <div className=\"content-grid\">\n        <div className=\"main-content\">\n          <Suspense fallback={<MainContentSkeleton />}>\n            <MainContent />\n          </Suspense>\n        </div>\n\n        <div className=\"sidebar\">\n          <Suspense fallback={<SidebarTopSkeleton />}>\n            <SidebarTopSection />\n          </Suspense>\n\n          <Suspense fallback={<SidebarBottomSkeleton />}>\n            <SidebarBottomSection />\n          </Suspense>\n        </div>\n      </div>\n\n      <Footer />\n    </Suspense>\n  );\n}\n\nUsing Next.js loading.js convention:\n// app/products/loading.tsx - This will automatically be used as a Suspense fallback\nexport default function Loading() {\n  return (\n    <div className=\"products-loading-skeleton\">\n      <div className=\"header-skeleton\" />\n      <div className=\"filters-skeleton\" />\n      <div className=\"products-grid-skeleton\">\n        {Array.from({ length: 12 }).map((_, i) => (\n          <div key={i} className=\"product-card-skeleton\" />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// app/products/page.tsx\nexport default async function ProductsPage() {\n  // This component can take time to load\n  // Next.js will automatically wrap it in Suspense\n  // and use the loading.js as the fallback\n  const products = await fetchProducts();\n\n  return <ProductsList products={products} />;\n}\n\n4. Client Components and Client-Side Rendering\nClient Components are defined using the React 'use client' directive. They are pre-rendered on the server but then hydrated on the client, enabling interactivity. This is different from pure client-side rendering (CSR), where rendering happens entirely in the browser. In the traditional sense of CSR (where the initial HTML is minimal, and all rendering happens in the browser), Next.js has moved away from this as a default approach but it can still be achievable by using dynamic imports and setting ssr: false.\n// app/csr-example/page.tsx\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport dynamic from 'next/dynamic';\n\n// Lazily load a component with no SSR\nconst ClientOnlyComponent = dynamic(\n  () => import('../components/heavy-component'),\n  { ssr: false, loading: () => <p>Loading...</p> }\n);\n\nexport default function CSRPage() {\n  const [isClient, setIsClient] = useState(false);\n\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  return (\n    <div>\n      <h1>Client-Side Rendered Page</h1>\n      {isClient ? (\n        <ClientOnlyComponent />\n      ) : (\n        <p>Loading client component...</p>\n      )}\n    </div>\n  );\n}\n\nDespite the shift toward server rendering, there are valid use cases for CSR:\nPrivate dashboards: Where SEO doesn't matter, and you want to reduce server load\nHeavy interactive applications: Like data visualization tools or complex editors\nBrowser-only APIs: When you need access to browser-specific features like localStorage or WebGL\nThird-party integrations: Some third-party widgets or libraries that only work in the browser\nWhile these are valid use cases, using Client Components is generally preferable to pure CSR in Next.js. Client Components give you the best of both worlds: server-rendered HTML for the initial load (improving SEO and LCP) with client-side interactivity after hydration. Pure CSR should be reserved for specific scenarios where server rendering is impossible or counterproductive.\nClient components are good for:\nInteractive UI elements: Forms, dropdowns, modals, tabs\nState-dependent UI: Components that change based on client state\nBrowser API access: Components that need localStorage, geolocation, etc.\nEvent-driven interactions: Click handlers, form submissions, animations\nReal-time updates: Chat interfaces, live notifications\nHow Client Components Affect Core Web Vitals\nLargest Contentful Paint (LCP): Initial HTML includes the server-rendered version of Client Components, so LCP is reasonably fast. Hydration can delay interactivity but doesn't necessarily affect LCP.\nInteraction to Next Paint (INP): For Client Components, hydration can cause input delay during page load, and when the page is hydrated, performance depends on the efficiency of event handlers. Also, complex state management can impact responsiveness.\nCumulative Layout Shift (CLS): Client-side data fetching can cause layout shifts as new data arrives. Also, state changes might alter the layout unexpectedly. Using Client Components will require careful implementation to prevent shifts.\nCode Examples:\nBasic Client Component:\n// app/components/Counter.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nClient Component with server data:\n// app/products/page.tsx - Server Component\nimport ProductFilter from '../components/ProductFilter';\n\nexport default async function ProductsPage() {\n  // Fetch data on the server\n  const products = await fetch('https://api.example.com/products').then(r => r.json());\n\n  // Pass server data to Client Component as props\n  return <ProductFilter initialProducts={products} />;\n}\n\nHybrid Approaches and Composition Patterns\nIn real-world applications, you'll often use a combination of rendering strategies to achieve the best performance. Next.js makes it easy to compose Server and Client Components together.\nServer Components with Islands of Interactivity\nOne of the most effective patterns is to use Server Components for the majority of your UI and add Client Components only where interactivity is needed. This approach:\nMinimizes JavaScript sent to the client\nProvides excellent initial load performance\nMaintains good interactivity where needed\n// app/products/[id]/page.tsx - Server Component\nimport AddToCartButton from '../../components/AddToCartButton';\nimport ProductReviews from '../../components/ProductReviews';\nimport RelatedProducts from '../../components/RelatedProducts';\n\nexport default async function ProductPage({ params }: {\n  params: { id: string; }\n}) {\n  // Fetch product data on the server\n  const product = await fetch(`https://api.example.com/products/${params.id}`).then(r => r.json());\n\n  return (\n    <div className=\"product-page\">\n      <div className=\"product-main\">\n        <h1>{product.name}</h1>\n        <p className=\"price\">${product.price.toFixed(2)}</p>\n        <div className=\"description\">{product.description}</div>\n\n        {/* Client Component for interactivity */}\n        <AddToCartButton product={product} />\n      </div>\n\n      {/* Server Component for product reviews */}\n      <ProductReviews productId={params.id} />\n\n      {/* Server Component for related products */}\n      <RelatedProducts categoryId={product.categoryId} />\n    </div>\n  );\n}\n\nPartial Prerendering (Next.js 15)\nNext.js 15 introduced Partial Prerendering, a new hybrid rendering strategy that combines static and dynamic content in a single route. This allows you to:\nStatically generate a shell of the page\nStream in dynamic, personalized content\nGet the best of both static and dynamic rendering\nNote: At the time of this writing, Partial Prerendering is experimental and is not ready for production use. Read more\n// app/dashboard/page.tsx\nimport { unstable_noStore as noStore } from 'next/cache';\nimport StaticContent from './components/StaticContent';\nimport DynamicContent from './components/DynamicContent';\n\nexport default function Dashboard() {\n  return (\n    <div className=\"dashboard\">\n      {/* This part is statically generated */}\n      <StaticContent />\n\n      {/* This part is dynamically rendered */}\n      <DynamicPart />\n    </div>\n  );\n}\n\n// This component and its children will be dynamically rendered\nfunction DynamicPart() {\n  // Opt out of caching for this part\n  noStore();\n\n  return <DynamicContent />;\n}\n\nMeasuring Core Web Vitals in Next.js\nUnderstanding the impact of your rendering strategy choices requires measuring Core Web Vitals in real-world conditions. Here are some approaches:\n1. Vercel Analytics\nIf you deploy on Vercel, you can use Vercel Analytics to automatically track Core Web Vitals for your production site:\n// app/layout.tsx\nimport { Analytics } from '@vercel/analytics/react';\n\nexport default function RootLayout({ children }: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  );\n}\n\n2. Web Vitals API\nYou can manually track Core Web Vitals using the web-vitals library:\n// app/components/WebVitalsReporter.tsx\n'use client';\n\nimport { useEffect } from 'react';\nimport { onCLS, onINP, onLCP } from 'web-vitals';\n\nexport function WebVitalsReporter() {\n  useEffect(() => {\n    // Report Core Web Vitals\n    onCLS(metric => console.log('CLS:', metric.value));\n    onINP(metric => console.log('INP:', metric.value));\n    onLCP(metric => console.log('LCP:', metric.value));\n\n    // In a real app, you would send these to your analytics service\n  }, []);\n\n  return null; // This component doesn't render anything\n}\n\n3. Lighthouse and PageSpeed Insights\nFor development and testing, use:\nChrome DevTools Lighthouse tab\nPageSpeed Insights\nChrome User Experience Report\nMaking Practical Decisions: Which Rendering Strategy to Choose?\nChoosing the right rendering strategy depends on your specific requirements. Here's a decision framework:\nChoose Static Rendering when\nContent is the same for all users\nData can be determined at build time\nPage doesn't need frequent updates\nSEO is critical\nYou want the best possible performance\nChoose Dynamic Rendering when\nContent is personalized for each user\nData must be fresh on every request\nYou need access to request-time information\nContent changes frequently\nChoose Streaming when\nPage has a mix of fast and slow data requirements\nYou want to improve perceived performance\nSome parts of the page depend on slow APIs\nYou want to prioritize showing critical UI first\nChoose Client Components when\nUI needs to be interactive\nComponent relies on browser APIs\nUI changes frequently based on user input\nYou need real-time updates\nConclusion\nNext.js provides a powerful set of rendering strategies that allow you to optimize for both performance and user experience. By understanding how each strategy affects Core Web Vitals, you can make informed decisions about how to build your application.\nRemember that the best approach is often a hybrid one, combining different rendering strategies based on the specific requirements of each part of your application. Start with Server Components as your default, use Static Rendering where possible, and add Client Components only where interactivity is needed.\nBy following these principles and measuring your Core Web Vitals, you can create Next.js applications that are fast, responsive, and provide an excellent user experience.",
          "itemLink": "https://www.thisdot.co/blog/next-js-rendering-strategies-and-how-they-affect-core-web-vitals"
        }
      ]
    },
    {
      "feedTitle": "ShopTalk",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "666: What Are the Evils of the Web Platform?",
          "media": "https://shoptalkshow.com/podcast-download/8228/666.mp3?nocache",
          "showNotes": "Show Description\nHow it all comes back to the why column, dark patterns, privacy and tracking, getting emails forever from one purchase, how to be bold with communication while still being respectful, HTMHell, CSS mistakes, are we anti-JSON, and the state of FitVid in 2025.\nListen on Website →\nLinks\n\nMarkup from hell - HTMHell\nIncomplete List of Mistakes in the Design of CSS [CSS Working Group Wiki]\nJSON Editing\nDouglas Crockford on JSON\nFluid Video Plugin\nSponsors",
          "itemLink": "https://shoptalkshow.com/666/"
        }
      ]
    },
    {
      "feedTitle": "Soft Skills Engineering",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Episode 462: Supporting laid-off employee and how to rebuild culture after layoffs",
          "media": "https://dts.podtrac.com/redirect.mp3/download.softskills.audio/sse-462.mp3?source=rss",
          "showNotes": "In this episode, Dave and Jamison answer these questions:\nOne of my employees is probably getting laid off, what do I do!?!\nI’m a tech lead / manager for a consultancy and a contract reduction means that one of the people I supervise is likely going to get laid off soon! We’ve found new roles for most of my people, but it’s likely that at least one will get laid off.\nI want to help this person out. How much support is typical for a manager / ex-manager to provide in a job search, and how can I go above and beyond without doing too much?\nOver the last year, my company has gone through 3 rounds of layoff. The engineering culture has changed dramatically. With the fraction of engineers remaining, I am increasingly concerned that it’s going to be me next. The company’s posture is that everything is “business as usual” and there is nothing to be worried about, but this is what has been said all along. Morale seems to be low with low engagement in department initiatives.\nI am looking for some advice here, if I stay with the company – what is a healthy way to engage with the current culture to build it back up (or evolve it into something new)? If I decide to leave the company – how can I set proper boundaries to prepare for leaving, but remain engaged until a new opportunity arises?",
          "itemLink": "https://softskills.audio/2025/05/26/episode-462-supporting-laid-off-employee-and-how-to-rebuild-culture-after-layoffs/"
        }
      ]
    },
    {
      "feedTitle": "Front-End Fire",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "VS Code Open Sources GitHub Copilot Chat",
          "media": "https://www.buzzsprout.com/2226499/episodes/17225284-vs-code-open-sources-github-copilot-chat.mp3",
          "showNotes": "This week both Google and Microsoft held conferences where they announced all the new, great AI breakthroughs, but there were a few other notable, web dev-focused pieces in between. VS Code announced it will be open sourcing the GitHub Copilot Chat extension, refactoring relevant components into its core codebase, as the next logical step “in making VS Code an open source AI editor.”\nMicrosoft has floated a new idea called “NLWeb” to make it easier for websites to turn themselves into AI apps using an LLM model and their own data. While this sounds interesting, it’s very early days yet and is not ready for prime time.\nA blog post from Remix creator Ryan Florence leaked earlier this week, and in it, Ryan shares that Remix v3 will move away from using React. The usual criticisms of React are present, and so Remix v3 will be completely new with a focus on a framework that’s AI friendly and leveraging all the Web APIs available today. \nNews:\n\nVS Code is open sourcing its AI chat extension\nRemix’s “Declaration of Independence” blog leaked\nAnd Microsoft introduces yet another AI standard\n\nLightning News:\n\nSatya Nadella and podcasts\nIntroducing Claude 4 \n\nWhat Makes Us Happy this Week:\n\nPaige - Daredevil: Born Again TV series\nJack -  Baseball team Portland Pickles’ Red Head Appreciation Night\nTJ - The Philadelphia Inquirer’s summer reading list\n\nThanks as always to our sponsor, the Blue Collar Coder channel on YouTube. You can join us in our Discord channel, explore our website and reach us via email, or talk to us on X, Bluesky, or YouTube.\n\nFront-end Fire website\nBlue Collar Coder on YouTube\nBlue Collar Coder on Discord\nReach out via email\nTweet at us on X @front_end_fire\nFollow us on Bluesky @front-end-fire.com\nSubscribe to our YouTube channel @Front-EndFirePodcast",
          "itemLink": "https://www.buzzsprout.com/2226499"
        }
      ]
    },
    {
      "feedTitle": "Modern Web",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Building a TikTok-Style App with React Native & Expo: Interview w Skylight Social CTO, Reed Harmeyer",
          "media": "https://anchor.fm/s/f9191780/podcast/play/103334846/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2025-4-28%2F401165513-44100-2-ec812e0f97d61.mp3",
          "showNotes": "In this episode of the Modern Web Podcast, Danny Thompson sits down with Reed Harmeyer, CTO of Skylight Social, and Brandon Mathis, React Native engineer at This Dot Labs. They unpack the technical and strategic decisions behind Skylight’s meteoric growth: why they built on the AT Protocol, how they tackled video discovery and scaling challenges, and how a fast-tracked in-app video editor gave them an edge.\n\n\nKeypoints from this episode:\n\nSkylight Social was built on the AT Protocol, allowing users to retain followers across platforms like Blue Sky and enabling creators to publish interoperable content in a decentralized social network.\n\nThe team used React Native with Expo to achieve rapid development and cross-platform performance—launching a high-quality, TikTok-like video experience in just days.\n\nAn in-app video editor was prioritized to reduce friction for creators, built using a native SDK wrapped with Expo Modules, enabling features like clip rearranging, overlays, voiceovers, and AI-generated captions.\n\nUser behavior data—specifically watch time—drives content recommendations, not just likes or follows, helping Skylight offer a personalized experience while navigating scaling challenges from hypergrowth.\n\n\n\nFollow Reed Harmeyer on Social Media\nBluesky: https://bsky.app/profile/reedharmeyer.bsky.social\nLinkedin: https://www.linkedin.com/in/reed-harmeyer/",
          "itemLink": "https://podcasters.spotify.com/pod/show/modern-web/episodes/Building-a-TikTok-Style-App-with-React-Native--Expo-Interview-w-Skylight-Social-CTO--Reed-Harmeyer-e33g1fu"
        }
      ]
    },
    {
      "feedTitle": "Indie Bites",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "devtools.fm: Developer Tools, Open Source, Software Development",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Greg Sadetsky, Antonie Leclair - Disco",
          "media": "https://anchor.fm/s/dd6922b4/podcast/play/103189293/https%3A%2F%2Fd3ctxlq1ktw2nl.cloudfront.net%2Fstaging%2F2025-4-25%2F400981004-44100-2-dad9bdc59c9aa.m4a",
          "showNotes": "This week we talk to Greg Sadetsky and Antoine Leclair, the creators of Disco. Disco make running you own infra a piece of cake.\n\nhttps://disco.cloud/\nhttps://docs.letsdisco.dev/\nhttps://github.com/letsdiscodev/\nhttps://github.com/gregsadetsky\nhttps://github.com/antoineleclair\n\n\nEpisode sponsored By WorkOS (https://workos.com).\nBecome a paid subscriber our patreon, spotify, or apple podcasts for the full episode.\n\nhttps://www.patreon.com/devtoolsfm\nhttps://podcasters.spotify.com/pod/show/devtoolsfm/subscribe\nhttps://podcasts.apple.com/us/podcast/devtools-fm/id1566647758\nhttps://www.youtube.com/@devtoolsfm/membership",
          "itemLink": "https://podcasters.spotify.com/pod/show/devtoolsfm/episodes/Greg-Sadetsky--Antonie-Leclair---Disco-e33bjbd"
        }
      ]
    },
    {
      "feedTitle": "DevTalles",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "HTTP 203",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Frontend First",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Svelte Radio",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "JS Party: JavaScript, CSS, Web Development",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "PodRocket - A web development podcast from LogRocket",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Relatively new things you should know about HTML with Chris Coyier (Repeat)",
          "media": "https://chrt.fm/track/7F1212/aphid.fireside.fm/d/1437767933/3911462c-bca2-48c2-9103-610ba304c673/91d26313-24a6-4ffa-bef9-1f249a04342e.mp3",
          "showNotes": "In this repeat episode, Chris Coyier, co-founder of CodePen, talks about the evolving landscape of HTML heading into 2025. He delves into topics like the slow evolution of HTML compared to CSS and JavaScript, the importance of backwards compatibility, new HTML elements and pseudo-elements, and the potential of declarative shadow DOM for server-side rendering in web components.\nLinks\nWebsite: https://chriscoyier.net\nCodepen: https://codepen.io/chriscoyier\nFrontend Social: https://front-end.social/@chriscoyier\nGithub: https://github.com/chriscoyier\nThreads: https://www.threads.net/@chriscoyier\nBluesky: https://bsky.app/profile/chriscoyier.net\nWe want to hear from you!\nHow did you find us? Did you see us on Twitter? In a newsletter? Or maybe we were recommended by a friend?\nLet us know by sending an email to our producer, Em, at emily.kochanek@logrocket.com (mailto:emily.kochanek@logrocket.com), or tweet at us at PodRocketPod (https://twitter.com/PodRocketpod).\nFollow us. Get free stickers.\nFollow us on Apple Podcasts, fill out this form (https://podrocket.logrocket.com/get-podrocket-stickers), and we’ll send you free PodRocket stickers!\nWhat does LogRocket do?\nLogRocket provides AI-first session replay and analytics that surfaces the UX and technical issues impacting user experiences. Start understanding where your users are struggling by trying it for free at LogRocket.com. Try LogRocket for free today. (https://logrocket.com/signup/?pdr) Special Guest: Chris Coyier.",
          "itemLink": "http://podrocket.logrocket.com/relatively-new-things-you-should-know-about-html-chris-coyier-repeat"
        }
      ]
    },
    {
      "feedTitle": "Web Rush",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Jamstack Radio",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "JavaScript Jabber",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "TypeScript, Security, and Type Juggling with Ariel Shulman & Liran Tal - JSJ 679",
          "media": "https://dts.podtrac.com/redirect.mp3/api.spreaker.com/download/episode/66327148/jsj_679.mp3",
          "showNotes": "In this episode, we dove headfirst into the swirling waters of TypeScript, its real-world use cases, and where it starts to fall short—especially when it comes to security. Joining us from sunny Tel Aviv (and a slightly cooler Portland), we had the brilliant Ariel Shulman and security advocate Liran Tal bring the heat on everything from type safety to runtime vulnerabilities.\n\nWe started off with a friendly debate: Has TypeScript really taken over the world? Our verdict? Pretty much. Whether it’s starter projects, enterprise codebases, or AI-generated snippets, TypeScript has become the de facto standard. But as we quickly found out, that doesn’t mean it’s perfect.\n\nKey Takeaways:\n-TypeScript ≠ Security\nWe tend to trust TypeScript a bit too much. It’s a build-time tool, not a runtime enforcer. As Liran pointed out, “TypeScript is not a security tool,” and treating it like one leads to dangerous assumptions.\n-Type Juggling is Real (and Sneaky)\nWe explored how something as innocent as using as string on request data can open the door to vulnerabilities like HTTP parameter pollution and prototype pollution. Just because your IDE is happy doesn’t mean your runtime is.\n-Enter Zod – Runtime Type Checking to the Rescue?\nZod got some love for bridging the dev-time/runtime gap by validating data on the fly and inferring TypeScript types. But even Zod isn’t foolproof. For example, unless you're using .strict(), extra fields can sneak past your validations, leading to mass assignment bugs.\n-Common Developer Fallacies\nWe discussed the misplaced confidence developers have in things like code coverage and TypeScript alone. One of the big takeaways: defense in depth matters. Just like testing, layering your security practices (like using Zod, type guards, and proper sanitization) is key.\n-TypeScript Best Practices Are Evolving\nFrom discriminated unions to avoiding any, from using Maps over plain objects to prevent prototype pollution—TypeScript developers are adapting. And tools like modern Node.js now support type stripping, which makes working with .ts files at runtime a bit easier.\n\nBecome a supporter of this podcast: https://www.spreaker.com/podcast/javascript-jabber--6102064/support.",
          "itemLink": "https://www.spreaker.com/episode/typescript-security-and-type-juggling-with-ariel-shulman-liran-tal-jsj-679--66327148"
        }
      ]
    },
    {
      "feedTitle": "DejaVue",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Syntax - Tasty Web Development Treats",
      "updateStatus": 2,
      "data": [
        {
          "itemTitle": "906: Tech Startups and Raising Money with Dan Levine (Vercel, Sentry, Mux…)",
          "media": "https://traffic.libsyn.com/secure/syntax/Syntax_-_906.mp3?dest-id=532671",
          "showNotes": "Wes and Scott talk with VC Dan Levine about how developers can raise venture capital, what investors look for in early-stage startups, the realities of bootstrapping vs. fundraising, and why great ideas often start as simple side projects.\n Show Notes\n  \n 00:00 Welcome to Syntax!\n  00:55 Dan’s background and career\n  03:10 Is it common for tech investors to come from a tech background?\n  04:40 How can developers raise money?\n  08:35 What investors look for\n  12:39 How much funding is enough?\n  15:41 Are founders working with multiple investors?\n  18:26 What can you use the money for?\n  22:49 How much influence do investors have in the business?\n  29:56 Brought to you by Sentry.io\n  29:56 How involved are VCs in the business?\n  34:22 How do you know a startup is in trouble—and what can you do about it?\n  38:56 How much of the company do investors own?\n  40:43 What’s the endgame for investors?\n  44:02 How do acqui-hires work?\n  46:29 Is the AI space a real opportunity or just hype?\n  53:22 Sick Picks + Shameless Plugs\n  \n Sick Picks\n  \n Dan: \n  Dandelion Chocolate\n  Jules Pizza\n  \n  \n Shameless Plugs\n  \n Dan: Linear\n  \n Hit us up on Socials!\n  Syntax: X Instagram Tiktok LinkedIn Threads\n  Wes: X Instagram Tiktok LinkedIn Threads\n  Scott: X Instagram Tiktok LinkedIn Threads\n  Randy: X Instagram YouTube Threads",
          "itemLink": "https://syntax.fm/906"
        },
        {
          "itemTitle": "905: You Should Learn Nuxt!",
          "media": "https://traffic.libsyn.com/secure/syntax/Syntax_-_905.mp3?dest-id=532671",
          "showNotes": "CJ steps in for Scott and joins Wes to share his experience working with Nuxt, from routing and data fetching to the pros and cons of the framework. They break down the Nuxt ecosystem, directory structure, and how it handles server routes and modules.\n Show Notes\n  \n 00:00 Syntax Meetup!\n  00:26 Welcome to Syntax\n  01:21 The deal with Nuxt. \n  CJ’s Nuxt Course.\n  \n  02:51 Why do you like Vue?\n  04:52 Brought to you by Sentry.io.\n  05:17 Routing with Nuxt. \n  h3 - The Web Framework for Modern JavaScript Era.\n  Nuxt Guides.\n  \n  06:12 Built on Nitro.\n  06:49 The Nuxt Ecosystem.\n  07:52 API Route Support.\n  08:15 Nuxt Directory Structure.\n  09:09 Does Nuxt do too much for you?\n  11:15 Data fetching in a Nuxt app.\n  13:25 RPC, Form Actions, Server Actions?\n  15:00 Nuxt Server Folder Hastle.\n  15:57 useFetch Hook. \n  CJ’s Nuxt Crash Course.\n  \n  17:29 Core Modules and Community Modules? \n  Nuxt Modules.\n  shadcn-nuxt.\n  @nuxt/ui.\n  DaisyUI.\n  Pinia.\n  \n  21:17 Nuxt Hosting. \n  Deploy.\n  hub.nuxt.\n  \n  23:59 Anything you don’t like?\n  \n Hit us up on Socials!\n  Syntax: X Instagram Tiktok LinkedIn Threads\n  Wes: X Instagram Tiktok LinkedIn Threads\n  Scott: X Instagram Tiktok LinkedIn Threads\n  Randy: X Instagram YouTube Threads",
          "itemLink": "https://syntax.fm/905"
        }
      ]
    },
    {
      "feedTitle": "Rust Review",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Front End Happy Hour",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "Off The Main Thread",
      "updateStatus": 0,
      "data": []
    },
    {
      "feedTitle": "The CSS Podcast",
      "updateStatus": 0,
      "data": []
    }
  ]
}