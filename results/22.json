{
  "startOfWeek": "2025-05-26",
  "weekNumber": 22,
  "availableItems": 11,
  "results": [
    {
      "feedTitle": "Whiskey Web and Whatnot: Web Development, Neat",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "The Myth of Perfect Code w/ Marc Backes",
          "media": "https://rss.art19.com/episodes/44535030-2888-42a8-926c-d03a9a6aef2c.mp3?rss_browser=BAhJIg9yc3MtcGFyc2VyBjoGRVQ%3D--42d668516e215326a0c0e36404173d504b339a70",
          "showNotes": "This week, Robbie and Chuck talk with Marc Backes about Vue vs. React, work-life balance, and the realities of messy codebases. They also sip an Evan Williams Single Barrel, debate inbox zero, and discuss Marc’s adventures in coffee roasting and pilot training.\nIn this episode:\n\n(00:00) - Intro\n(01:45) - Whiskey review and rating: Evan Williams Single Barrel\n(09:03) - Hot Take: Inferred types vs explicit types\n(10:04) - Hot Take: Tailwind vs vanilla CSS\n(10:59) - Hot Take: Git Rebase vs Git Merge\n(11:27) - Nested ternaries?\n(15:58) - Real code vs ideal code\n(21:43) - Why work/life balance matters\n(30:28) - Why Marc chose Vue over React\n(31:19) - Ryan Reynolds speaking at Post/Con\n(32:40) - Render Atlanta and upcoming conferences\n(33:48) - Marc's connection to Mexico\n(34:54) - Discussing different foods\n(37:09) - Marc's inbox zero strategy\n(40:26) - Learning to fly\n(44:06) - Roasting coffee as a hobby\n(46:13) - Personal branding and standing out\n(51:19) - Plugs\n\nLinks\n\nEvan Williams Single Barrel: https://evanwilliams.com/single-barrel\nVue: https://vuejs.org/\nNuxt: https://nuxt.com/\nNorlan: https://norlanglass.com/\nNintendo: https://www.nintendo.com/\nSwitch 2: https://www.nintendo.com/us/gaming-systems/switch-2/\nDouble Double Oaked Woodford: https://www.woodfordreserve.com/whiskey/double-double-oaked/\nTypescript: https://www.typescriptlang.org/\nTailwind CSS: https://tailwindcss.com/\nReact: https://react.dev/\njQuery: https://jquery.com/\nRyan Reynolds: https://en.wikipedia.org/wiki/Ryan_Reynolds\nPost Con: https://postcon.postman.com/\nAviation Gin: https://www.aviationgin.com/\nMint Mobile: https://www.mintmobile.com/\nRender Conf: https://www.renderatl.com/\nTaco Bell: https://www.tacobell.com/\nMarc Backes - Achieving Inbox Zero: https://marc.dev/blog/inbox-zero\nSuperhuman: https://superhuman.com/\nVim: https://www.vim.org/\nVue: https://vuejs.org/\nVite: https://vite.dev/\nTerminal Coffee: https://www.terminal.shop/\nDax: https://x.com/thdxr/\nJack Daniel's: https://www.jackdaniels.com/\nKelly Vaughn: https://x.com/kvlly\n\nConnect with Marc\n\nWebsite: https://marc.dev/\nX / Twitter: https://x.com/themarcba\n\nConnect with Chuck and Robbie\n\nRobbie Wagner: https://x.com/RobbieTheWagner\nChuck Carpenter: https://x.com/CharlesWthe3rd\n\nSubscribe and stay in touch\n\nWebsite: https://whiskey.fm\nApple Podcasts: https://podcasts.apple.com/us/podcast/whiskey-web-and-whatnot/id1552776603\nSpotify: https://open.spotify.com/show/19jiuHAqzeKnkleQUpZxDf\nOvercast: https://overcast.fm/itunes1552776603\nYouTube: https://www.youtube.com/@WhiskeyWebAndWhatnot\n\nWhiskey Web and Whatnot Merch\nEnjoying the podcast and want us to make more? Help support us by picking up some of our fresh merch at https://whiskey.fund.\nSee Privacy Policy at https://art19.com/privacy and California Privacy Notice at https://art19.com/privacy#do-not-sell-my-info.",
          "itemLink": "https://art19.com/shows/whiskey-web-and-whatnot"
        }
      ]
    },
    {
      "feedTitle": "This Dot Labs RSS feed",
      "updateStatus": 1,
      "data": [
        {
          "itemTitle": "Next.js Rendering Strategies and how they affect core web vitals",
          "media": null,
          "showNotes": "When it comes to building fast and scalable web apps with Next.js, it’s important to understand how rendering works, especially with the App Router. Next.js organizes rendering around two main environments: the server and the client. On the server side, you’ll encounter three key strategies: Static Rendering, Dynamic Rendering, and Streaming. Each one comes with its own set of trade-offs and performance benefits, so knowing when to use which is crucial for delivering a great user experience.\nIn this post, we'll break down each strategy, what it's good for, and how it impacts your site's performance, especially Core Web Vitals. We'll also explore hybrid approaches and provide practical guidance on choosing the right strategy for your use case.\nWhat Are Core Web Vitals?\nCore Web Vitals are a set of metrics defined by Google that measure real-world user experience on websites. These metrics play a major role in search engine rankings and directly affect how users perceive the speed and smoothness of your site.\nLargest Contentful Paint (LCP): This measures loading performance. It calculates the time taken for the largest visible content element to render. A good LCP is 2.5 seconds or less.\nInteraction to Next Paint (INP): This measures responsiveness to user input. A good INP is 200 milliseconds or less.\nCumulative Layout Shift (CLS): This measures the visual stability of the page. It quantifies layout instability during load. A good CLS is 0.1 or less.\nIf you want to dive deeper into Core Web Vitals and understand more about their impact on your website's performance, I recommend reading this detailed guide on  New Core Web Vitals and How They Work.\nNext.js Rendering Strategies and Core Web Vitals\nLet's explore each rendering strategy in detail:\n1. Static Rendering (Server Rendering Strategy)\nStatic Rendering is the default for Server Components in Next.js. With this approach, components are rendered at build time (or during revalidation), and the resulting HTML is reused for each request. This pre-rendering happens on the server, not in the user's browser. Static rendering is ideal for routes where the data is not personalized to the user, and this makes it suitable for:\nContent-focused websites: Blogs, documentation, marketing pages\nE-commerce product listings: When product details don't change frequently\nSEO-critical pages: When search engine visibility is a priority\nHigh-traffic pages: When you want to minimize server load\nHow Static Rendering Affects Core Web Vitals\nLargest Contentful Paint (LCP): Static rendering typically leads to excellent LCP scores (typically < 1s). The Pre-rendered HTML can be cached and delivered instantly from CDNs, resulting in very fast delivery of the initial content, including the largest element. Also, there is no waiting for data fetching or rendering on the client.\nInteraction to Next Paint (INP): Static rendering provides a good foundation for INP, but doesn't guarantee optimal performance (typically ranges from 50-150 ms depending on implementation). While Server Components don't require hydration, any Client Components within the page still need JavaScript to become interactive. To achieve a very good INP score, you will need to make sure the Client Components within the page is minimal.\nCumulative Layout Shift (CLS): While static rendering delivers the complete page structure upfront which can be very beneficial for CLS, achieving excellent CLS requires additional optimization strategies:\nStatic HTML alone doesn't prevent layout shifts if resources load asynchronously\nImage dimensions must be properly specified to reserve space before the image loads\nWeb fonts can cause text to reflow if not handled properly with font display strategies\nDynamically injected content (ads, embeds, lazy-loaded elements) can disrupt layout stability\nCSS implementation significantly impacts CLS—immediate availability of styling information helps maintain visual stability\nCode Examples:\nBasic static rendering:\n// app/page.tsx (Server Component - Static Rendering by default)\nexport default async function Page() {\n  const res = await fetch('https://api.example.com/static-data');\n  const data = await res.json();\n  return (\n    <div>\n      <h1>Static Content</h1>\n      <p>{data.content}</p>\n    </div>\n  );\n}\n\nStatic rendering with revalidation (ISR):\n// app/dashboard/page.tsx\nexport default async function Dashboard() {\n  // Static data that revalidates every day\n  const siteStats = await fetch('https://api.example.com/site-stats', {\n    next: { revalidate: 86400 } // 24 hours\n  }).then(r => r.json());\n\n  // Data that revalidates every hour\n  const popularProducts = await fetch('https://api.example.com/popular-products', {\n    next: { revalidate: 3600 } // 1 hour\n  }).then(r => r.json());\n\n  // Data with a cache tag for on-demand revalidation\n  const featuredContent = await fetch('https://api.example.com/featured-content', {\n    next: { tags: ['featured'] }\n  }).then(r => r.json());\n\n  return (\n    <div className=\"dashboard\">\n      <section className=\"stats\">\n        <h2>Site Statistics</h2>\n        <p>Total Users: {siteStats.totalUsers}</p>\n        <p>Total Orders: {siteStats.totalOrders}</p>\n      </section>\n\n      <section className=\"popular\">\n        <h2>Popular Products</h2>\n        <ul>\n          {popularProducts.map(product => (\n            <li key={product.id}>{product.name} - {product.sales} sold</li>\n          ))}\n        </ul>\n      </section>\n\n      <section className=\"featured\">\n        <h2>Featured Content</h2>\n        <div>{featuredContent.html}</div>\n      </section>\n    </div>\n  );\n}\n\nStatic path generation:\n// app/products/[id]/page.tsx\nexport async function generateStaticParams() {\n  const products = await fetch('https://api.example.com/products').then(r => r.json());\n\n  return products.map((product) => ({\n    id: product.id.toString(),\n  }));\n}\n\nexport default async function Product({ params }) {\n  const product = await fetch(`https://api.example.com/products/${params.id}`).then(r => r.json());\n\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>${product.price.toFixed(2)}</p>\n      <p>{product.description}</p>\n    </div>\n  );\n}\n\n2. Dynamic Rendering (Server Rendering Strategy)\nDynamic Rendering generates HTML on the server for each request at request time. Unlike static rendering, the content is not pre-rendered or cached but freshly generated for each user. This kind of rendering works best for:\nPersonalized content: User dashboards, account pages\nReal-time data: Stock prices, live sports scores\nRequest-specific information: Pages that use cookies, headers, or search parameters\nFrequently changing data: Content that needs to be up-to-date on every request\nHow Dynamic Rendering Affects Core Web Vitals\nLargest Contentful Paint (LCP): With dynamic rendering, the server needs to generate HTML for each request, and that can't be fully cached at the CDN level. It is still faster than client-side rendering as HTML is generated on the server.\nInteraction to Next Paint (INP): The performance is similar to static rendering once the page is loaded. However, it can become slower if the dynamic content includes many Client Components.\nCumulative Layout Shift (CLS): Dynamic rendering can potentially introduce CLS if the data fetched at request time significantly alters the layout of the page compared to a static structure. However, if the layout is stable and the dynamic content size fits within predefined areas, the CLS can be managed effectively.\nCode Examples:\nExplicit dynamic rendering:\n// app/dashboard/page.tsx\nexport const dynamic = 'force-dynamic'; // Force this route to be dynamically rendered\n\nexport default async function Dashboard() {\n  // This will run on every request\n  const data = await fetch('https://api.example.com/dashboard-data').then(r => r.json());\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <p>Last updated: {new Date().toLocaleString()}</p>\n      {/* Dashboard content */}\n    </div>\n  );\n}\n\nSimplicit dynamic rendering with cookies:\n// app/profile/page.tsx\nimport { cookies } from 'next/headers';\n\nexport default async function Profile() {\n  // Using cookies() automatically opts into dynamic rendering\n  const userId = cookies().get('userId')?.value;\n\n  const user = await fetch(`https://api.example.com/users/${userId}`).then(r => r.json());\n\n  return (\n    <div>\n      <h1>Welcome, {user.name}</h1>\n      <p>Email: {user.email}</p>\n      {/* Profile content */}\n    </div>\n  );\n}\n\nDynamic routes:\n// app/blog/[slug]/page.tsx\nexport default async function BlogPost({ params }) {\n  // It will run at request time for any slug not explicitly pre-rendered\n  const post = await fetch(`https://api.example.com/posts/${params.slug}`).then(r => r.json());\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div>{post.content}</div>\n    </article>\n  );\n}\n\n3. Streaming (Server Rendering Strategy)\nStreaming allows you to progressively render UI from the server. Instead of waiting for all the data to be ready before sending any HTML, the server sends chunks of HTML as they become available. This is implemented using React's Suspense boundary.\nReact Suspense works by creating boundaries in your component tree that can \"suspend\" rendering while waiting for asynchronous operations. When a component inside a Suspense boundary throws a promise (which happens automatically with data fetching in React Server Components), React pauses rendering of that component and its children, renders the fallback UI specified in the Suspense component, continues rendering other parts of the page outside this boundary, and eventually resumes and replaces the fallback with the actual component once the promise resolves.\nWhen streaming, this mechanism allows the server to send the initial HTML with fallbacks for suspended components while continuing to process suspended components in the background. The server then streams additional HTML chunks as each suspended component resolves, including instructions for the browser to seamlessly replace fallbacks with final content. It works well for:\nPages with mixed data requirements: Some fast, some slow data sources\nImproving perceived performance: Show users something quickly while slower parts load\nComplex dashboards: Different widgets have different loading times\nHandling slow APIs: Prevent slow third-party services from blocking the entire page\nHow Streaming Affects Core Web Vitals\nLargest Contentful Paint (LCP): Streaming can improve the perceived LCP. By sending the initial HTML content quickly, including potentially the largest element, the browser can render it sooner. Even if other parts of the page are still loading, the user sees the main content faster.\nInteraction to Next Paint (INP): Streaming can contribute to a better INP. When used with React's &lt;Suspense />, interactive elements in the faster-loading parts of the page can become interactive earlier, even while other components are still being streamed in. This allows users to engage with the page sooner.\nCumulative Layout Shift (CLS): Streaming can cause layout shifts as new content streams in. However, when implemented carefully, streaming should not negatively impact CLS. The initially streamed content should establish the main layout, and subsequent streamed chunks should ideally fit within this structure without causing significant reflows or layout shifts. Using placeholders and ensuring dimensions are known can help prevent CLS.\nCode Examples:\nBasic Streaming with Suspense:\n// app/dashboard/page.tsx\nimport { Suspense } from 'react';\nimport UserProfile from './components/UserProfile';\nimport RecentActivity from './components/RecentActivity';\nimport PopularPosts from './components/PopularPosts';\n\nexport default function Dashboard() {\n  return (\n    <div className=\"dashboard\">\n      {/* This loads quickly */}\n      <h1>Dashboard</h1>\n\n      {/* User profile loads first */}\n      <Suspense fallback={<div className=\"skeleton-profile\">Loading profile...</div>}>\n        <UserProfile />\n      </Suspense>\n\n      {/* Recent activity might take longer */}\n      <Suspense fallback={<div className=\"skeleton-activity\">Loading activity...</div>}>\n        <RecentActivity />\n      </Suspense>\n\n      {/* Popular posts might be the slowest */}\n      <Suspense fallback={<div className=\"skeleton-posts\">Loading popular posts...</div>}>\n        <PopularPosts />\n      </Suspense>\n    </div>\n  );\n}\n\nNested Suspense boundaries for more granular control:\n// app/complex-page/page.tsx\nimport { Suspense } from 'react';\n\nexport default function ComplexPage() {\n  return (\n    <Suspense fallback={<PageSkeleton />}>\n      <Header />\n\n      <div className=\"content-grid\">\n        <div className=\"main-content\">\n          <Suspense fallback={<MainContentSkeleton />}>\n            <MainContent />\n          </Suspense>\n        </div>\n\n        <div className=\"sidebar\">\n          <Suspense fallback={<SidebarTopSkeleton />}>\n            <SidebarTopSection />\n          </Suspense>\n\n          <Suspense fallback={<SidebarBottomSkeleton />}>\n            <SidebarBottomSection />\n          </Suspense>\n        </div>\n      </div>\n\n      <Footer />\n    </Suspense>\n  );\n}\n\nUsing Next.js loading.js convention:\n// app/products/loading.tsx - This will automatically be used as a Suspense fallback\nexport default function Loading() {\n  return (\n    <div className=\"products-loading-skeleton\">\n      <div className=\"header-skeleton\" />\n      <div className=\"filters-skeleton\" />\n      <div className=\"products-grid-skeleton\">\n        {Array.from({ length: 12 }).map((_, i) => (\n          <div key={i} className=\"product-card-skeleton\" />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// app/products/page.tsx\nexport default async function ProductsPage() {\n  // This component can take time to load\n  // Next.js will automatically wrap it in Suspense\n  // and use the loading.js as the fallback\n  const products = await fetchProducts();\n\n  return <ProductsList products={products} />;\n}\n\n4. Client Components and Client-Side Rendering\nClient Components are defined using the React 'use client' directive. They are pre-rendered on the server but then hydrated on the client, enabling interactivity. This is different from pure client-side rendering (CSR), where rendering happens entirely in the browser. In the traditional sense of CSR (where the initial HTML is minimal, and all rendering happens in the browser), Next.js has moved away from this as a default approach but it can still be achievable by using dynamic imports and setting ssr: false.\n// app/csr-example/page.tsx\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport dynamic from 'next/dynamic';\n\n// Lazily load a component with no SSR\nconst ClientOnlyComponent = dynamic(\n  () => import('../components/heavy-component'),\n  { ssr: false, loading: () => <p>Loading...</p> }\n);\n\nexport default function CSRPage() {\n  const [isClient, setIsClient] = useState(false);\n\n  useEffect(() => {\n    setIsClient(true);\n  }, []);\n\n  return (\n    <div>\n      <h1>Client-Side Rendered Page</h1>\n      {isClient ? (\n        <ClientOnlyComponent />\n      ) : (\n        <p>Loading client component...</p>\n      )}\n    </div>\n  );\n}\n\nDespite the shift toward server rendering, there are valid use cases for CSR:\nPrivate dashboards: Where SEO doesn't matter, and you want to reduce server load\nHeavy interactive applications: Like data visualization tools or complex editors\nBrowser-only APIs: When you need access to browser-specific features like localStorage or WebGL\nThird-party integrations: Some third-party widgets or libraries that only work in the browser\nWhile these are valid use cases, using Client Components is generally preferable to pure CSR in Next.js. Client Components give you the best of both worlds: server-rendered HTML for the initial load (improving SEO and LCP) with client-side interactivity after hydration. Pure CSR should be reserved for specific scenarios where server rendering is impossible or counterproductive.\nClient components are good for:\nInteractive UI elements: Forms, dropdowns, modals, tabs\nState-dependent UI: Components that change based on client state\nBrowser API access: Components that need localStorage, geolocation, etc.\nEvent-driven interactions: Click handlers, form submissions, animations\nReal-time updates: Chat interfaces, live notifications\nHow Client Components Affect Core Web Vitals\nLargest Contentful Paint (LCP): Initial HTML includes the server-rendered version of Client Components, so LCP is reasonably fast. Hydration can delay interactivity but doesn't necessarily affect LCP.\nInteraction to Next Paint (INP): For Client Components, hydration can cause input delay during page load, and when the page is hydrated, performance depends on the efficiency of event handlers. Also, complex state management can impact responsiveness.\nCumulative Layout Shift (CLS): Client-side data fetching can cause layout shifts as new data arrives. Also, state changes might alter the layout unexpectedly. Using Client Components will require careful implementation to prevent shifts.\nCode Examples:\nBasic Client Component:\n// app/components/Counter.tsx\n'use client';\n\nimport { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nClient Component with server data:\n// app/products/page.tsx - Server Component\nimport ProductFilter from '../components/ProductFilter';\n\nexport default async function ProductsPage() {\n  // Fetch data on the server\n  const products = await fetch('https://api.example.com/products').then(r => r.json());\n\n  // Pass server data to Client Component as props\n  return <ProductFilter initialProducts={products} />;\n}\n\nHybrid Approaches and Composition Patterns\nIn real-world applications, you'll often use a combination of rendering strategies to achieve the best performance. Next.js makes it easy to compose Server and Client Components together.\nServer Components with Islands of Interactivity\nOne of the most effective patterns is to use Server Components for the majority of your UI and add Client Components only where interactivity is needed. This approach:\nMinimizes JavaScript sent to the client\nProvides excellent initial load performance\nMaintains good interactivity where needed\n// app/products/[id]/page.tsx - Server Component\nimport AddToCartButton from '../../components/AddToCartButton';\nimport ProductReviews from '../../components/ProductReviews';\nimport RelatedProducts from '../../components/RelatedProducts';\n\nexport default async function ProductPage({ params }: {\n  params: { id: string; }\n}) {\n  // Fetch product data on the server\n  const product = await fetch(`https://api.example.com/products/${params.id}`).then(r => r.json());\n\n  return (\n    <div className=\"product-page\">\n      <div className=\"product-main\">\n        <h1>{product.name}</h1>\n        <p className=\"price\">${product.price.toFixed(2)}</p>\n        <div className=\"description\">{product.description}</div>\n\n        {/* Client Component for interactivity */}\n        <AddToCartButton product={product} />\n      </div>\n\n      {/* Server Component for product reviews */}\n      <ProductReviews productId={params.id} />\n\n      {/* Server Component for related products */}\n      <RelatedProducts categoryId={product.categoryId} />\n    </div>\n  );\n}\n\nPartial Prerendering (Next.js 15)\nNext.js 15 introduced Partial Prerendering, a new hybrid rendering strategy that combines static and dynamic content in a single route. This allows you to:\nStatically generate a shell of the page\nStream in dynamic, personalized content\nGet the best of both static and dynamic rendering\nNote: At the time of this writing, Partial Prerendering is experimental and is not ready for production use. Read more\n// app/dashboard/page.tsx\nimport { unstable_noStore as noStore } from 'next/cache';\nimport StaticContent from './components/StaticContent';\nimport DynamicContent from './components/DynamicContent';\n\nexport default function Dashboard() {\n  return (\n    <div className=\"dashboard\">\n      {/* This part is statically generated */}\n      <StaticContent />\n\n      {/* This part is dynamically rendered */}\n      <DynamicPart />\n    </div>\n  );\n}\n\n// This component and its children will be dynamically rendered\nfunction DynamicPart() {\n  // Opt out of caching for this part\n  noStore();\n\n  return <DynamicContent />;\n}\n\nMeasuring Core Web Vitals in Next.js\nUnderstanding the impact of your rendering strategy choices requires measuring Core Web Vitals in real-world conditions. Here are some approaches:\n1. Vercel Analytics\nIf you deploy on Vercel, you can use Vercel Analytics to automatically track Core Web Vitals for your production site:\n// app/layout.tsx\nimport { Analytics } from '@vercel/analytics/react';\n\nexport default function RootLayout({ children }: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        {children}\n        <Analytics />\n      </body>\n    </html>\n  );\n}\n\n2. Web Vitals API\nYou can manually track Core Web Vitals using the web-vitals library:\n// app/components/WebVitalsReporter.tsx\n'use client';\n\nimport { useEffect } from 'react';\nimport { onCLS, onINP, onLCP } from 'web-vitals';\n\nexport function WebVitalsReporter() {\n  useEffect(() => {\n    // Report Core Web Vitals\n    onCLS(metric => console.log('CLS:', metric.value));\n    onINP(metric => console.log('INP:', metric.value));\n    onLCP(metric => console.log('LCP:', metric.value));\n\n    // In a real app, you would send these to your analytics service\n  }, []);\n\n  return null; // This component doesn't render anything\n}\n\n3. Lighthouse and PageSpeed Insights\nFor development and testing, use:\nChrome DevTools Lighthouse tab\nPageSpeed Insights\nChrome User Experience Report\nMaking Practical Decisions: Which Rendering Strategy to Choose?\nChoosing the right rendering strategy depends on your specific requirements. Here's a decision framework:\nChoose Static Rendering when\nContent is the same for all users\nData can be determined at build time\nPage doesn't need frequent updates\nSEO is critical\nYou want the best possible performance\nChoose Dynamic Rendering when\nContent is personalized for each user\nData must be fresh on every request\nYou need access to request-time information\nContent changes frequently\nChoose Streaming when\nPage has a mix of fast and slow data requirements\nYou want to improve perceived performance\nSome parts of the page depend on slow APIs\nYou want to prioritize showing critical UI first\nChoose Client Components when\nUI needs to be interactive\nComponent relies on browser APIs\nUI changes frequently based on user input\nYou need real-time updates\nConclusion\nNext.js provides a powerful set of rendering strategies that allow you to optimize for both performance and user experience. By understanding how each strategy affects Core Web Vitals, you can make informed decisions about how to build your application.\nRemember that the best approach is often a hybrid one, combining different rendering strategies based on the specific requirements of each part of your application. Start with Server Components as your default, use Static Rendering where possible, and add Client Components only where interactivity is needed.\nBy following these principles and measuring your Core Web Vitals, you can create Next.js applications that are fast, responsive, and provide an excellent user experience.",
          "itemLink": "https://www.thisdot.co/blog/next-js-rendering-strategies-and-how-they-affect-core-web-vitals"
        }
      ]
    }
  ]
}